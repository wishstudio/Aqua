namespace Core;

using Core.Native;

class Number
{
	private static int32 Error_NoError, Error_Format, Error_Overflow;

	static ()
	{
		InitNumber();
	}

	/* HACK: Temporary workaround */
	public static InitNumber()
	{
		Error_NoError = 0;
		Error_Format = 1;
		Error_Overflow = 2;
	}

	/* ToString functions */
	public static ToString(int32 number) -> String
	{
		if (number == -2147483648)
			return "-2147483648";
		/* -2147483647: length is 11 */
		int buffer = Memory.AllocateMemory(22);
		int32 n = Math.Abs(number), i = 22;
		do
		{
			i = i - 2;
			*(buffer + i) = [char] (n % 10 + 48); /* '0' */
			n = n / 10;
		}
		while (n > 0);
		if (number < 0)
		{
			i = i - 2;
			*(buffer + i) = [char] 45; /* '-' */
		}
		String ret = String.FromCharBuffer(buffer + i, (22 - i) / 2);
		Memory.FreeMemory(buffer);
		return ret;
	}

	public static ToString(uint32 number) -> String
	{
		/* 4294967295: length is 10 */
		int buffer = Memory.AllocateMemory(20);
		int32 i = 20;
		do
		{
			i = i - 2;
			*(buffer + i) = [char] (number % 10 + 48); /* '0' */
			number = number / 10;
		}
		/* HACK: uint32 */
		while ([int32] number != 0);
		String ret = String.FromCharBuffer(buffer + i, (22 - i) / 2);
		Memory.FreeMemory(buffer);
		return ret;
	}

	/* Parse functions */
	public static ParseInt32(String str) -> int32
	{
		int32 errcode, num;
		errcode, num = ParseInt32Core(str);
		if (errcode == Error_Format)
			throw new FormatException();
		else if (errcode == Error_Overflow)
			throw new OverflowException();
		else
			return num;
	}

	public static TryParseInt32(String str) -> bool, int32
	{
		int32 errcode, num;
		errcode, num = ParseInt32Core(str);
		if (errcode == Error_NoError)
			return true, num;
		else
			return false, 0;
	}

	public static ParseInt32Core(String str) -> int32, int32
	{
		int32 ret = 0;
		if ([int32] str[0] == '-')
		{
			for (int32 i = 1; i < str.Length; i = i + 1)
			{
				int32 digit = [int32] str[i] - '0';
				if (digit < 0 || digit > 9)
					return Error_Format, 0;
				if (ret < -214748364 || (ret == -214748364 && digit > 8))
					return Error_Overflow, 0;
				ret = ret * 10 - digit;
			}
			return Error_NoError, ret;
		}
		else
		{
			for (int32 i = 0; i < str.Length; i = i + 1)
			{
				int32 digit = [int32] str[i] - '0';
				if (digit < 0 || digit > 9)
					return Error_Format, 0;
				if (ret > 214748364 || (ret == 214748364 && digit > 7))
					return Error_Overflow, 0;
				ret = ret * 10 + digit;
			}
			return Error_NoError, ret;
		}
	}

	public static ParseUInt32(String str) -> uint32
	{
		int32 errcode;
		uint32 num;
		errcode, num = ParseUInt32Core(str);
		if (errcode == Error_Format)
			throw new FormatException();
		else if (errcode == Error_Overflow)
			throw new OverflowException();
		else
			return num;
	}

	public static TryParseUInt32(String str) -> bool, uint32
	{
		int32 errcode;
		uint32 num;
		errcode, num = ParseUInt32Core(str);
		if (errcode == Error_NoError)
			return true, num;
		else
			return false, 0;
	}

	public static ParseUInt32Core(String str) -> int32, uint32
	{
		uint32 ret = 0;
		for (int32 i = 0; i < str.Length; i = i + 1)
		{
			/* HACK: uint32 */
			int32 digit = [int32] str[i] - '0';
			if (digit < 0 || digit > 9)
				return Error_Format, 0;
			if ([int32] ret > 429496729 || ([int32] ret == 429496729 && digit > 5))
				return Error_Overflow, 0;
			ret = ret * 10 + [uint32] digit;
		}
		return Error_NoError, ret;
	}
}
