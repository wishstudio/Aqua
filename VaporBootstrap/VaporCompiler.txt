class CompilerException
{
	public Core.String message;
	public Location location;

	public (Core.String message, Location location)
	{
		this::message = message;
		this::location = location;
	}

	public ToString() -> Core.String
	{
		return location::ToString() + ": " + message;
	}
}

class Variable
{
	public int32 regid;
	public Type type;
}

class Context
{
	public static int32 Loop, TryCatch, Finally;

	public int32 loopLevel, tryCatchLevel, finallyLevel;
	public int32 continueLabelId;
	public int32 breakLabelId;
	public int32 firstReturnRegister;
	public Stack contextType;
	/* HACK: bool */
	public int32 generateEpilogue;

	public ()
	{
		contextType = new Stack();
	}

	public static InitContext()
	{
		Context::Loop, Context::TryCatch, Context::Finally = 1, 2, 3;
	}
}

class Compiler
{
	private Hash classes;

	public Vector code;
	private int32 tab;
	private Stack symbolTable; /* Stack of symbol hashes */
	private Class currentClass;
	private Method currentMethod;
	private int32 currentLabelId;

	public Hash Classes
	{
		get { return classes; }
	}

	public Class CurrentClass
	{
		get { return currentClass; }
	}

	public Method CurrentMethod
	{
		get { return currentMethod; }
	}

	public (Hash classes)
	{
		this::classes = classes;
		code = new Vector();
		symbolTable = new Stack();
	}

	private GetLabelName(int32 labelId) -> Core.String
	{
		return "_L" + labelId;
	}

	private GetNextLabelId() -> int32
	{
		currentLabelId = currentLabelId + 1;
		return currentLabelId - 1;
	}

	private AddCode(Core.String line)
	{
		Core.String tabs = "";
		for (int32 i = 0; i < tab; i = i + 1)
			tabs = tabs + "\t";
		code::Add([Core.Object] (tabs + line));
	}

	private AddLabel(int32 labelId)
	{
		code::Add([Core.Object] (GetLabelName(labelId) + ":"));
	}

	private AddStringLabel(Core.String label)
	{
		code::Add([Core.Object] (label + ":"));
	}

	private Tab()
	{
		tab = tab + 1;
	}

	private Untab()
	{
		tab = tab - 1;
	}

	private PushSymbolStack()
	{
		symbolTable::Push([Core.Object] new Hash());
	}

	private PopSymbolStack()
	{
		symbolTable::Pop();
	}

	private FindSymbol(Core.String name) -> Variable, int32
	{
		for (int32 i = symbolTable::Size - 1; i >= 0; i = i - 1)
		{
			int32 found;
			Core.Object ret;
			if ((found, ret = ([Hash] symbolTable::data[i])::Contains(name)) > 0)
				return [Variable] ret, 1;
		}
		return null, 0;
	}

	public static GetOperatorMethodName(int32 op) -> Core.String
	{
		if (op == Token::Add)
			return ".opAdd";
		else if (op == Token::Sub)
			return ".opSub";
		else if (op == Token::Mul)
			return ".opMul";
		else if (op == Token::Div)
			return ".opDiv";
		else if (op == Token::Rem)
			return ".opRem";
		else if (op == Token::LT)
			return ".opLT";
		else if (op == Token::LE)
			return ".opLE";
		else if (op == Token::GT)
			return ".opGT";
		else if (op == Token::GE)
			return ".opGE";
		else if (op == Token::EQ)
			return ".opEQ";
		else if (op == Token::NEQ)
			return ".opNEQ";
		else if (op == Token::Array)
			return ".opArrayElement";
		else
			return null;
	}

	public GetMethodSignature(Method method) -> Core.String
	{
		return method::classObject::name + "::" + method::name + ResolvePrototype(method);
	}
	
	private ToScalar(Vector values) -> Value
	{
		if (values::Size == 0)
			throw new Core.Exception(); /* TODO */
		return [Value] values[0];
	}

	private Scalar(Value value) -> Vector
	{
		Vector ret = new Vector();
		ret::Add([Core.Object] value);
		return ret;
	}

	public Compile()
	{
		/* Set class::baseClass */
		/* HACK: iterator */
		for (int32 i = 0; i < classes::Size; i = i + 1)
		{
			Class current = [Class] classes::values[i];
			if (current::baseName::Equals("") == 0)
			{
				Core.Object baseClass;
				int32 found;
				found, baseClass = classes::Contains(current::baseName);
				if (found == 0)
					throw new CompilerException("Unknown base class \"" + current::baseName + "\".", current::location);
				current::baseClass = [Class] baseClass;
			}
		}

		tab = 0;
		Vector classes = this::classes::values;
		for (int32 i = 0; i < classes::Size; i = i + 1)
		{
			currentClass = [Class] classes[i];
			if (currentClass::baseClass == null)
				AddCode(".class " + currentClass::name);
			else
				AddCode(".class " + currentClass::name + ": " + currentClass::baseClass::name);
			AddCode("{");
			Tab();

			Vector fields = currentClass::fields::values;
			for (int32 j = 0; j < fields::Size; j = j + 1)
				CompileField([Field] fields[j]);

			Vector properties = currentClass::properties::values;
			for (int32 j = 0; j < properties::Size; j = j + 1)
				CompileProperty([Property] properties[j]);

			Vector methods = currentClass::methods::values;
			for (int32 j = 0; j < methods::Size; j = j + 1)
				CompileMethod([Method] methods[j]);

			Untab();
			AddCode("}");
		}
	}

	private CompileField(Field field)
	{
		Core.String modifier = Modifier::ToString(field::modifier);
		if (modifier::Length > 0)
			modifier = modifier + " ";
		AddCode(".field " + modifier + ResolveType(field::type)::ToString() + " " + field::name);
	}

	private CompileProperty(Property property)
	{
		Core.String modifier = Modifier::ToString(property::modifier);
		if (modifier::Length > 0)
			modifier = modifier + " ";
		AddCode(".property " + modifier + ResolveType(property::type)::ToString() + " " + property::name);
		if (property::getter != null)
			AddCode("\t.get " + GetMethodSignature(property::getter));
		if (property::setter != null)
			AddCode("\t.set " + GetMethodSignature(property::setter));
	}

	private CompileMethod(Method method)
	{
		Core.String modifier = Modifier::ToString(method::modifier);
		if (modifier::Length > 0)
			modifier = modifier + " ";

		AddCode(".method " + modifier + "function " + method::name + ResolvePrototype(method));

		if (method::modifier & Modifier::Internal > 0 || method::modifier & Modifier::Abstract > 0)
		{
			/* Do nothing */
		}
		else if (method::modifier & Modifier::Native > 0)
		{
			AddCode("[" + CallingConvention::ToString(method::callingConvention) + ", \"" + method::libraryName
				+ "\", \"" + method::originalName + "\"]");
		}
		else
		{
			/* Check for improper override */
			if (method::modifier & Modifier::Override > 0)
			{
				/* Check if it actually overrides a method */
				/* HACK: bool */
				int32 ok = 0;
				Class c = method::classObject;
				while (c::baseClass != null)
				{
					c = c::baseClass;
					Vector methods = c::methods::FindAll(method::name);
					/* HACK: bool */
					int32 done = 0;
					for (int32 i = 0; i < methods::Size; i = i + 1)
					{
						Method another = [Method] methods[i];
						if (ResolvePrototype(method)::Equals(ResolvePrototype(another)) > 0)
						{
							if (another::modifier & Modifier::Virtual > 0 || another::modifier & Modifier::Abstract > 0)
							{
								done = 1;
								ok = 1;
								break;
							}
							else if (another::modifier & Modifier::Override == 0)
							{
								done = 1;
								break;
							}
						}
					}
					if (done > 0)
						break;
				}
				if (ok == 0)
					throw new CompilerException("The method \"" + method::name
						+ "\" makred with \"override\" does not override any methods.", method::location);
			}
			else
			{
				/* TODO: Check implicit override and display a warning */
			}

			AddCode("{");
			Tab();
			PushSymbolStack();

			Context context = new Context();
			int32 freereg = 0;
			if (method::modifier & Modifier::Static == 0)
				freereg = freereg + 1;

			for (int32 i = 0; i < method::paramNames::Size; i = i + 1)
			{
				Core.String name = [Core.String] method::paramNames[i];
				if (name::Equals("") == 0)
				{
					Variable var = new Variable();
					var::regid = freereg + i;
					var::type = ResolveType([ParserType] method::paramTypes[i]);
					([Hash] symbolTable::Peek())::Add(name, [Core.Object] var);
				}
			}
			freereg = freereg + method::paramNames::Size;
			context::firstReturnRegister = freereg;
			for (int32 i = 0; i < method::returnNames::Size; i = i + 1)
			{
				Core.String name = [Core.String] method::returnNames[i];
				if (name::Equals("") == 0)
				{
					Variable var = new Variable();
					var::regid = freereg + i;
					var::type = ResolveType([ParserType] method::returnTypes[i]);
					([Hash] symbolTable::Peek())::Add(name, [Core.Object] var);
				}
			}
			freereg = freereg + method::returnNames::Size;

			currentMethod = method;
			currentLabelId = 1;
			int32 closed = method::body::CompileStatement(this, freereg, context);
			if (closed == 0 || context::generateEpilogue > 0)	
			{
				if (context::generateEpilogue > 0)
					AddStringLabel("_Epilogue");
				/* Unclosed statement block, insert return statement manually */
				if (method::returnNames::Size == 0)
					AddCode("ret");
				else if (method::returnNames::Size == 1)
					AddCode("ret\t$" + context::firstReturnRegister);
				else
					AddCode("ret\t$" + context::firstReturnRegister + ", $"
						+ (context::firstReturnRegister + method::returnTypes::Size));
			}

			PopSymbolStack();
			Untab();
			AddCode("}");
		}
	}

	private FixJumpTarget(int32 jtarget) -> int32
	{
		if (jtarget == 0)
		{
			currentLabelId = currentLabelId + 1;
			return currentLabelId - 1;
		}
		else
			return jtarget;
	}

	/* Convert types to a unified stack type for doing arithmetic */
	private UnifyTypes(Node node, Value left, Value right, int32 leftreg, int32 rightreg) -> Value, Value
	{
		/* TODO: Immediate value */
		Type type;

		if (left::CanImplicitlyConvertTo(Type::Int8) > 0 && right::CanImplicitlyConvertTo(Type::Int8) > 0)
			type = Type::Int8;
		else if (left::CanImplicitlyConvertTo(Type::UInt8) > 0 && right::CanImplicitlyConvertTo(Type::UInt8) > 0)
			type = Type::UInt8;
		else if (left::CanImplicitlyConvertTo(Type::Int16) > 0 && right::CanImplicitlyConvertTo(Type::Int16) > 0)
			type = Type::Int16;
		else if (left::CanImplicitlyConvertTo(Type::UInt16) > 0 && right::CanImplicitlyConvertTo(Type::UInt16) > 0)
			type = Type::UInt16;
		else if (left::CanImplicitlyConvertTo(Type::Int32) > 0 && right::CanImplicitlyConvertTo(Type::Int32) > 0)
			type = Type::Int32;
		else if (left::CanImplicitlyConvertTo(Type::UInt32) > 0 && right::CanImplicitlyConvertTo(Type::UInt32) > 0)
			type = Type::UInt32;
		else
			throw new CompilerException("Uncompatible types.", node::location);

		Value l = left::ToTyped(this, leftreg, type);
		Value r = right::ToTyped(this, rightreg, type);

		return l, r;
	}

	/* Convert to a typed value from its corresponding raw stack value */
	private FixRawValue(RegisterValue value, int32 targetreg) -> RegisterValue
	{
		/* TODO: Immediate value */
		Type stackType = value::type::StackType;
		if (value::type::Equals(stackType) == 0)
		{
			RegisterValue ret = value::EnsureRegister(this, targetreg);
			AddCode("conv\t" + value::type::ToString() + " $" + targetreg + ", "
				+ stackType::ToString() + " $" + value::regid);
			value::regid = targetreg;
			return value;
		}
		else
			return value;
	}

	private CompileCustomBinaryOperator(Node node, int32 op, Value left, Value right, int32 firstreg) -> Value
	{
		Value l = left::EnsureSingleSlot(this, firstreg);
		Value r = right::EnsureSingleSlot(this, firstreg + 1);

		Core.String methodName = GetOperatorMethodName(op);
		if (methodName == null)
			throw new CompilerException("Unsupported operator.", node::location);

		Vector methods = new Vector();
		if (l::type is ClassType)
			ResolveMethod(([ClassType] l::type)::Class, methodName, methods);
		if (r::type is ClassType)
			ResolveMethod(([ClassType] r::type)::Class, methodName, methods);

		Vector values = new Vector();
		values::Add(l);
		values::Add(r);

		Method method = PrepareCall(node, methods, values, firstreg);
		AddCode("call\t$" + firstreg + ", " + GetMethodSignature(method));
		return new RegisterValue(node::location, firstreg, ResolveType([ParserType] method::returnTypes[0]));
	}

	/* Resolves a type from standarized type string */
	private ResolveParserType(Location location, Core.String type) -> Type
	{
		if (type::Equals("bool") > 0)
			return Type::Bool;
		else if (type::Equals("int8") > 0)
			return Type::Int8;
		else if (type::Equals("uint8") > 0)
			return Type::UInt8;
		else if (type::Equals("int16") > 0)
			return Type::Int16;
		else if (type::Equals("uint16") > 0)
			return Type::UInt16;
		else if (type::Equals("int32") > 0)
			return Type::Int32;
		else if (type::Equals("uint32") > 0)
			return Type::UInt32;
		else if (type::Equals("char") > 0)
			return Type::Char;
		else if (type::Equals("int") > 0)
			return Type::Int;
		else if (type::SubString(type::Length - 2, 2)::Equals("[]") > 0)
			return new ArrayType(ResolveParserType(location, type::SubString(0, type::Length - 2)));
		else if (type::SubString(type::Length - 1, 1)::Equals("*") > 0)
			return new PointerType(ResolveParserType(location, type::SubString(0, type::Length - 1)));
		else
		{
			Core.Object c;
			int32 found;
			found, c = classes::Contains(type);
			if (found == 0)
				throw new CompilerException("Unknown type \"" + type + "\".", location);
			return new ClassType([Class] c);
		}
	}

	private ResolveType(ParserType type) -> Type
	{
		if (type::type == null)
			type::type = ResolveParserType(type::location, type::typestring);
		return type::type;
	}

	private ResolvePrototype(Method method) -> Core.String
	{
		if (method::prototype == null)
		{
			/* Concatenate prototype string */
			Core.String prototype = "(";
			for (int32 i = 0; i < method::paramTypes::Size; i = i + 1)
			{
				if (i == 0)
					prototype = prototype + ResolveType([ParserType] method::paramTypes[i])::ToString();
				else
					prototype = prototype + ", " + ResolveType([ParserType] method::paramTypes[i])::ToString();
			}
			prototype = prototype + ")";
			if (method::returnTypes::Size > 0)
			{
				prototype = prototype + " -> ";
				for (int32 i = 0; i < method::returnTypes::Size; i = i + 1)
				{
					if (i == 0)
						prototype = prototype + ResolveType([ParserType] method::returnTypes[i])::ToString();
					else
						prototype = prototype + ", " + ResolveType([ParserType] method::returnTypes[i])::ToString();
				}
			}
			method::prototype = prototype;
		}
		return method::prototype;
	}

	/* Resolves a field, returns null if not found */
	private ResolveField(Class startClass, Core.String name) -> Field
	{
		Class c = startClass;
		while (c != null)
		{
			Core.Object field;
			int32 found;
			if ((found, field = c::fields::Contains(name)) > 0)
				return [Field] field;
			c = c::baseClass;
		}
		return null;
	}

	/* Resolves a property, returns null if not found */
	private ResolveProperty(Class startClass, Core.String name) -> Property
	{
		Class c = startClass;
		while (c != null)
		{
			Core.Object property;
			int32 found;
			if ((found, property = c::properties::Contains(name)) > 0
				&& ([Property] property)::modifier & Modifier::Override == 0)
					return [Property] property;
			c = c::baseClass;
		}
		return null;
	}

	/* Resolves a method by name, append possible candidates to `methods` vector */
	private ResolveMethod(Class startClass, Core.String name, Vector methods) -> Vector
	{
		if (methods == null)
			methods = new Vector();
		Class c = startClass;
		while (c != null)
		{
			ResolveMethodInClass(c, name, methods);
			c = c::baseClass;
		}
		return methods;
	}

	/* Resolves a method in a single class */
	private ResolveMethodInClass(Class classObject, Core.String name, Vector methods) -> Vector
	{
		if (methods == null)
			methods = new Vector();
		Vector current = classObject::methods::FindAll(name);
		for (int32 i = 0; i < current::Size; i = i + 1)
		{
			Method method = [Method] current[i];
			if (method::modifier & Modifier::Override == 0) /* Do not include overridden methods */
			{
				/* HACK: bool */
				int32 ok = 1;
				/* Make sure this method is not overridden by a subclass method */
				for (int32 j = 0; j < methods::Size; j = j + 1)
				{
					Method another = [Method] methods[j];
					if (ResolvePrototype(method)::Equals(ResolvePrototype(another)) > 0)
					{
						ok = 0;
						break;
					}
				}
				if (ok > 0)
					methods::Add([Core.Object] method);
			}
		}
		return methods;
	}

	/* Choose best method in `methods`,
	   Ensures `values` are converted to proper types and placed sequentially from `firstreg`
	   Returns best method */
	private PrepareCall(Node node, Vector methods, Vector values, int32 firstreg) -> Method
	{
		Vector candidates = new Vector();
		/* Check valid candidates */
		for (int32 i = 0; i < methods::Size; i = i + 1)
		{
			Method method = [Method] methods[i];
			if (method::paramTypes::Size == values::Size)
			{
				/* HACK: bool */
				int32 ok = 1;
				for (int32 j = 0; j < method::paramTypes::Size; j = j + 1)
					if (([Value] values[j])::CanImplicitlyConvertTo(ResolveType([ParserType] method::paramTypes[j])) == 0)
					{
						ok = 0;
						break;
					}
				if (ok > 0)
					candidates::Add([Core.Object] method);
			}
		}
		Method method = ChooseBestMethod(node, candidates, values);
		/* Prepare values */
		for (int32 i = 0; i < values::Size; i = i + 1)
			([Value] values[i])::ToTypedRegister(
				this, firstreg + i, firstreg + i, ResolveType([ParserType] method::paramTypes[i])
			);
		return method;
	}

	/* S = Given type, T1 = Method 1 type, T2 = Method 2 type
	 * `->` means implicitly convertible
	 * Rules:
	 * 1. If T1 = T2, neither is better.
	 * 2. If S = T1, T1 is better.
	 *    If S = T2, T2 is better.
	 * 3. If T1 -> T2 and not T2 -> T1, T1 is beter.
	 *    If T2 -> T1 and not T1 -> T2, T2 is better.
	 * 4. Otherwise, neither is better.
	 */
	private ChooseBestMethod(Node node, Vector methods, Vector values) -> Method
	{
		if (methods::Size == 0)
			throw new CompilerException("No method prototype match type of given parameters.", node::location);
		for (int32 i = 0; i < methods::Size; i = i + 1)
		{
			Method current = [Method] methods[i];
			/* HACK: bool */
			int32 ok = 1;
			for (int32 j = 0; j < methods::Size; j = j + 1)
				if (i != j)
				{
					Method another = [Method] methods[j];
					/* HACK: bool */
					int32 better = 0;
					for (int32 k = 0; k < values::Size; k = k + 1)
					{
						Type S = ([Value] values[k])::type;
						Type T1 = ResolveType([ParserType] current::paramTypes[k]);
						Type T2 = ResolveType([ParserType] another::paramTypes[k]);
						if (T1::Equals(T2) > 0)
							continue;
						if (S::Equals(T1) > 0)
						{
							better = 1;
							continue;
						}
						if (S::Equals(T2) > 0)
						{
							better = 0;
							break;
						}
						/* HACK: bool */
						int32 c1 = T1::CanImplicitlyConvertTo(T2), c2 = T2::CanImplicitlyConvertTo(T1);
						if (c1 > 0 && c2 == 0)
							better = 1;
						else if (c1 == 0 && c2 > 0)
						{
							better = 0;
							break;
						}
					}
					/* Best method must be better than any other method */
					if (better == 0)
					{
						ok = 0;
						break;
					}
				}
			if (ok > 0)
				return current;
		}
		throw new CompilerException("Ambiguous function call.", node::location);
	}
}
