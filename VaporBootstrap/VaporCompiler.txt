class CompilerException
{
	public Core.String message;
	public Location location;

	public function .ctor(Core.String message, Location location)
	{
		this::message = message;
		this::location = location;
	}

	public function ToString() -> Core.String
	{
		return location::ToString() + ": " + message;
	}
}

class Variable
{
	public int32 regid;
	public Type type;
}

class Context
{
	public static int32 Loop, TryCatch, Finally;

	public int32 loopLevel, tryCatchLevel, finallyLevel;
	public int32 continueLabelId;
	public int32 breakLabelId;
	public int32 firstReturnRegister;
	public Stack contextType;
	/* HACK: bool */
	public int32 generateEpilogue;

	public function .ctor()
	{
		contextType = new Stack();
	}

	public static function InitContext()
	{
		Context::Loop, Context::TryCatch, Context::Finally = 1, 2, 3;
	}
}

class Compiler
{
	private Hash classes;

	public Vector code;
	private int32 tab;
	private Stack symbolTable; /* Stack of symbol hashes */
	private Class currentClass;
	private Method currentMethod;
	private int32 currentLabelId;

	public function .ctor(Hash classes)
	{
		this::classes = classes;
		code = new Vector();
		symbolTable = new Stack();
	}

	private function GetLabelName(int32 labelId) -> Core.String
	{
		return "_L" + Core.Int32::ToString(labelId);
	}

	private function GetNextLabelId() -> int32
	{
		currentLabelId = currentLabelId + 1;
		return currentLabelId - 1;
	}

	private function AddCode(Core.String line)
	{
		Core.String tabs = "";
		for (int32 i = 0; i < tab; i = i + 1)
			tabs = tabs + "\t";
		code::Add([Core.Object] (tabs + line));
	}

	private function AddLabel(int32 labelId)
	{
		code::Add([Core.Object] (GetLabelName(labelId) + ":"));
	}

	private function AddStringLabel(Core.String label)
	{
		code::Add([Core.Object] (label + ":"));
	}

	private function Tab()
	{
		tab = tab + 1;
	}

	private function Untab()
	{
		tab = tab - 1;
	}

	private function PushSymbolStack()
	{
		symbolTable::Push([Core.Object] new Hash());
	}

	private function PopSymbolStack()
	{
		symbolTable::Pop();
	}

	private function FindSymbol(Core.String name) -> Variable, int32
	{
		for (int32 i = symbolTable::.getSize() - 1; i >= 0; i = i - 1)
		{
			int32 found;
			Core.Object ret;
			if ((found, ret = ([Hash] symbolTable::data[i])::Contains(name)) > 0)
				return [Variable] ret, 1;
		}
		return null, 0;
	}

	public static function GetOperatorMethodName(int32 op) -> Core.String
	{
		if (op == Token::Add)
			return ".opAdd";
		else if (op == Token::Sub)
			return ".opSub";
		else if (op == Token::Mul)
			return ".opMul";
		else if (op == Token::Div)
			return ".opDiv";
		else if (op == Token::Rem)
			return ".opRem";
		else if (op == Token::LT)
			return ".opLT";
		else if (op == Token::LE)
			return ".opLE";
		else if (op == Token::GT)
			return ".opGT";
		else if (op == Token::GE)
			return ".opGE";
		else if (op == Token::EQ)
			return ".opEQ";
		else if (op == Token::NEQ)
			return ".opNEQ";
		else if (op == Token::Array)
			return ".opArrayElement";
		else
			return null;
	}
	
	private function ToScalar(Vector values) -> Value
	{
		if (values::.getSize() == 0)
			throw new Core.Exception(); /* TODO */
		return [Value] values[0];
	}

	private function Scalar(Value value) -> Vector
	{
		Vector ret = new Vector();
		ret::Add([Core.Object] value);
		return ret;
	}

	public function Compile()
	{
		/* Set class::baseClass */
		/* HACK: iterator */
		for (int32 i = 0; i < classes::.getSize(); i = i + 1)
		{
			Class current = [Class] classes::values[i];
			if (current::baseName::Equals("") == 0)
			{
				Core.Object baseClass;
				int32 found;
				found, baseClass = classes::Contains(current::baseName);
				if (found == 0)
					throw new CompilerException("Unknown base class \"" + current::baseName + "\".", current::location);
				current::baseClass = [Class] baseClass;
			}
		}

		tab = 0;
		Vector classes = this::classes::values;
		for (int32 i = 0; i < classes::.getSize(); i = i + 1)
		{
			currentClass = [Class] classes[i];
			if (currentClass::baseClass == null)
				AddCode(".class " + currentClass::name);
			else
				AddCode(".class " + currentClass::name + ": " + currentClass::baseClass::name);
			AddCode("{");
			Tab();

			Vector fields = currentClass::fields::values;
			for (int32 j = 0; j < fields::.getSize(); j = j + 1)
				CompileField([Field] fields[j]);

			Vector methods = currentClass::methods::values;
			for (int32 j = 0; j < methods::.getSize(); j = j + 1)
				CompileMethod([Method] methods[j]);

			Untab();
			AddCode("}");
		}
	}

	private function CompileField(Field field)
	{
		Core.String modifier = Modifier::ToString(field::modifier);
		if (modifier::.getLength() > 0)
			modifier = modifier + " ";
		AddCode(".field " + modifier + ResolveType(field::type)::ToString() + " " + field::name);
	}

	private function CompileMethod(Method method)
	{
		Core.String modifier = Modifier::ToString(method::modifier);
		if (modifier::.getLength() > 0)
			modifier = modifier + " ";

		AddCode(".method " + modifier + "function " + method::name + ResolvePrototype(method));

		if (method::modifier & Modifier::Internal > 0 || method::modifier & Modifier::Abstract > 0)
		{
			/* Do nothing */
		}
		else if (method::modifier & Modifier::Native > 0)
		{
			AddCode("[" + CallingConvention::ToString(method::callingConvention) + ", \"" + method::libraryName
				+ "\", \"" + method::originalName + "\"]");
		}
		else
		{
			/* Check for improper override */
			if (method::modifier & Modifier::Override > 0)
			{
				/* Check if it actually overrides a method */
				/* HACK: bool */
				int32 ok = 0;
				Class c = method::classObject;
				while (c::baseClass != null)
				{
					c = c::baseClass;
					Vector methods = c::methods::FindAll(method::name);
					/* HACK: bool */
					int32 done = 0;
					for (int32 i = 0; i < methods::.getSize(); i = i + 1)
					{
						Method another = [Method] methods[i];
						if (ResolvePrototype(method)::Equals(ResolvePrototype(another)) > 0)
						{
							if (another::modifier & Modifier::Virtual > 0 || another::modifier & Modifier::Abstract > 0)
							{
								done = 1;
								ok = 1;
								break;
							}
							else if (another::modifier & Modifier::Override == 0)
							{
								done = 1;
								break;
							}
						}
					}
					if (done > 0)
						break;
				}
				if (ok == 0)
					throw new CompilerException("The method \"" + method::name
						+ "\" makred with \"override\" does not override any methods.", method::location);
			}
			else
			{
				/* TODO: Check implicit override and display a warning */
			}

			AddCode("{");
			Tab();
			PushSymbolStack();

			Context context = new Context();
			int32 freereg = 0;
			if (method::modifier & Modifier::Static == 0)
				freereg = freereg + 1;

			for (int32 i = 0; i < method::paramNames::.getSize(); i = i + 1)
			{
				Core.String name = [Core.String] method::paramNames[i];
				if (name::Equals("") == 0)
				{
					Variable var = new Variable();
					var::regid = freereg + i;
					var::type = ResolveType([ParserType] method::paramTypes[i]);
					([Hash] symbolTable::Peek())::Add(name, [Core.Object] var);
				}
			}
			freereg = freereg + method::paramNames::.getSize();
			context::firstReturnRegister = freereg;
			for (int32 i = 0; i < method::returnNames::.getSize(); i = i + 1)
			{
				Core.String name = [Core.String] method::returnNames[i];
				if (name::Equals("") == 0)
				{
					Variable var = new Variable();
					var::regid = freereg + i;
					var::type = ResolveType([ParserType] method::returnTypes[i]);
					([Hash] symbolTable::Peek())::Add(name, [Core.Object] var);
				}
			}
			freereg = freereg + method::returnNames::.getSize();

			currentMethod = method;
			currentLabelId = 1;
			int32 closed = CompileStatement(method::body, freereg, context);
			if (closed == 0 || context::generateEpilogue > 0)	
			{
				if (context::generateEpilogue > 0)
					AddStringLabel("_Epilogue");
				/* Unclosed statement block, insert return statement manually */
				if (method::returnNames::.getSize() == 0)
					AddCode("ret");
				else if (method::returnNames::.getSize() == 1)
					AddCode("ret\t$" + Core.Int32::ToString(context::firstReturnRegister));
				else
					AddCode("ret\t$" + Core.Int32::ToString(context::firstReturnRegister) + ", $"
						+ Core.Int32::ToString(context::firstReturnRegister + method::returnTypes::.getSize()));
			}

			PopSymbolStack();
			Untab();
			AddCode("}");
		}
	}

	/* Returns whether the statement block is fully closed (has return statements in all possible control flows) */
	/* Returns 'closed' and 'nextfreereg' */
	private function CompileStatement(Node node, int32 freereg, Context context) -> int32, int32
	{
		if (node::op == Token::MultipleNode)
		{
			PushSymbolStack();
			int32 closed = 0, _freereg = freereg;
			MultipleNode mnode = [MultipleNode] node;
			for (int32 i = 0; i < mnode::nodes::.getSize(); i = i + 1)
				closed, _freereg = CompileStatement([Node] mnode::nodes[i], _freereg, context);
			PopSymbolStack();
			return closed, freereg;
		}
		else if (node::op == Token::Definition)
		{
			DefinitionNode dnode = [DefinitionNode] node;
			for (int32 i = 0; i < dnode::names::.getSize(); i = i + 1)
			{
				Variable variable = new Variable();
				variable::regid = freereg;
				variable::type = ResolveType(dnode::type);

				([Hash] symbolTable::Peek())::Add([Core.String] dnode::names[i], [Core.Object] variable);
				Variable var = FindSymbol([Core.String] dnode::names[i]);

				Core.Object vn = dnode::values[i];
				if (vn != null)
				{
					Node vnode = [Node] vn;
					LValue value = new VariableValue(freereg, ResolveType(dnode::type));
					CompileExpression(vnode, freereg, freereg, 0, 0)::ToLValue(this, vnode::location, value, freereg);
				}
				freereg = freereg + 1;
			}
			return 0, freereg;
		}
		else if (node::op == Token::If)
		{
			IfNode inode = [IfNode] node;
			if (inode::falseBody == null)
			{
				/* If - Then */
				int32 falseTarget = GetNextLabelId();
				CompileExpression(inode::condition, freereg, freereg, falseTarget, 0)
					::ToJumpTarget(this, inode::condition::location, freereg, falseTarget, 0);
				CompileStatement(inode::trueBody, freereg, context);
				AddLabel(falseTarget);
				return 0, freereg;
			}
			else
			{
				/* If - Then - Else */
				int32 falseTarget = GetNextLabelId();
				int32 endTarget = GetNextLabelId();
				CompileExpression(inode::condition, freereg, freereg, falseTarget, 0)
					::ToJumpTarget(this, inode::condition::location, freereg, falseTarget, 0);
				int32 thenClosed, elseClosed;
				thenClosed = CompileStatement(inode::trueBody, freereg, context);
				if (thenClosed == 0)
					AddCode("jmp\t" + GetLabelName(endTarget));
				AddLabel(falseTarget);
				elseClosed = CompileStatement(inode::falseBody, freereg, context);
				if (thenClosed == 0)
					AddLabel(endTarget);
				return thenClosed & elseClosed, freereg;
			}
		}
		else if (node::op == Token::For)
		{
			PushSymbolStack();
			context::loopLevel = context::loopLevel + 1;
			int32 backupContinueLabelId = context::continueLabelId;
			int32 backupBreakLabelId = context::breakLabelId;
			context::contextType::Push([Core.Object] Core.Int32::ToString(Context::Loop));

			ForNode fnode = [ForNode] node;
			int32 bodyTarget = GetNextLabelId();
			int32 conditionTarget;
			if (fnode::condition != null)
				conditionTarget = GetNextLabelId();
			int32 closed, _freereg = freereg;

			context::continueLabelId = 0;
			context::breakLabelId = 0;
			if (fnode::condition == null && fnode::update == null)
				context::continueLabelId = bodyTarget;

			if (fnode::init != null)
				closed, _freereg = CompileStatement(fnode::init, freereg, context);
			if (fnode::condition != null)
				AddCode("jmp\t" + GetLabelName(conditionTarget));
			AddLabel(bodyTarget);
			CompileStatement(fnode::body, _freereg, context);
			if ((fnode::condition != null || fnode::update != null) && context::continueLabelId > 0)
				AddLabel(context::continueLabelId);
			if (fnode::update != null)
				CompileList(fnode::update, _freereg, -1);
			if (fnode::condition == null)
				AddCode("jmp\t" + GetLabelName(bodyTarget));
			else
			{
				AddLabel(conditionTarget);
				CompileExpression(fnode::condition, _freereg, _freereg, bodyTarget, 1)
					::ToJumpTarget(this, fnode::condition::location, _freereg, bodyTarget, 1);
			}

			if (context::breakLabelId > 0)
				AddLabel(context::breakLabelId);
			context::contextType::Pop();
			context::continueLabelId = backupContinueLabelId;
			context::breakLabelId = backupBreakLabelId;
			context::loopLevel = context::loopLevel - 1;
			PopSymbolStack();
			return 0, freereg;
		}
		else if (node::op == Token::While)
		{
			context::loopLevel = context::loopLevel + 1;
			int32 backupContinueLabelId = context::continueLabelId;
			int32 backupBreakLabelId = context::breakLabelId;
			context::contextType::Push([Core.Object] Core.Int32::ToString(Context::Loop));

			WhileNode wnode = [WhileNode] node;
			int32 bodyTarget = GetNextLabelId();
			int32 conditionTarget = GetNextLabelId();

			context::continueLabelId = conditionTarget;
			context::breakLabelId = 0;
			AddCode("jmp\t" + GetLabelName(conditionTarget));
			AddLabel(bodyTarget);
			CompileStatement(wnode::body, freereg, context);
			AddLabel(conditionTarget);
			CompileExpression(wnode::condition, freereg, freereg, bodyTarget, 1)
				::ToJumpTarget(this, wnode::condition::location, freereg, bodyTarget, 1);

			if (context::breakLabelId > 0)
				AddLabel(context::breakLabelId);
			context::contextType::Pop();
			context::continueLabelId = backupContinueLabelId;
			context::breakLabelId = backupBreakLabelId;
			context::loopLevel = context::loopLevel - 1;
			return 0, freereg;
		}
		else if (node::op == Token::Do)
		{
			context::loopLevel = context::loopLevel + 1;
			int32 backupContinueLabelId = context::continueLabelId;
			int32 backupBreakLabelId = context::breakLabelId;
			context::contextType::Push([Core.Object] Core.Int32::ToString(Context::Loop));

			WhileNode wnode = [WhileNode] node;
			int32 bodyTarget = GetNextLabelId();

			context::continueLabelId = 0;
			context::breakLabelId = 0;
			AddLabel(bodyTarget);
			CompileStatement(wnode::body, freereg, context);
			if (context::continueLabelId > 0)
				AddLabel(context::continueLabelId);
			CompileExpression(wnode::condition, freereg, freereg, bodyTarget, 1)
				::ToJumpTarget(this, wnode::condition::location, freereg, bodyTarget, 1);

			if (context::breakLabelId > 0)
				AddLabel(context::breakLabelId);
			context::contextType::Pop();
			context::continueLabelId = backupContinueLabelId;
			context::breakLabelId = backupBreakLabelId;
			context::loopLevel = context::loopLevel - 1;
			return 0, freereg;
		}
		else if (node::op == Token::Return)
		{
			ReturnNode rnode = [ReturnNode] node;
			if (rnode::values::.getSize() != currentMethod::returnTypes::.getSize() && rnode::values::.getSize() != 0)
				throw new CompilerException("Unmatched number of return values.", node::location);
			if (context::finallyLevel > 0)
				throw new CompilerException("Control cannot go out of the finally block.", node::location);
			if (context::tryCatchLevel > 0)
			{
				/* We are inside a try finally block */
				/* First, save supplied return values into return registers */
				for (int32 i = 0; i < rnode::values::.getSize(); i = i + 1)
				{
					Node vnode = [Node] rnode::values[i];
					/* TODO: Type */
					CompileExpression(vnode, freereg, context::firstReturnRegister + i, 0, 0)
						::ToRegister(this, context::firstReturnRegister + 1);
				}
				/* Second, add leave instruction */
				AddCode("leave\t_Epilogue");
				/* Last, tell CompileMethod() that we need an epilogue */
				context::generateEpilogue = 1;
			}
			else
			{
				/* Normal return */
				if (currentMethod::returnTypes::.getSize() == 0)
					AddCode("ret");
				else if (currentMethod::returnTypes::.getSize() == 1)
				{
					if (rnode::values::.getSize() == 0)
						AddCode("ret\t$" + Core.Int32::ToString(context::firstReturnRegister));
					else
					{
						RegisterValue value = CompileExpression([Node] rnode::values[0], freereg, freereg, 0, 0)
							::EnsureRegister(this, freereg);
						AddCode("ret\t$" + Core.Int32::ToString(value::regid));
					}
				}
				else
				{
					if (rnode::values::.getSize() == 0)
						AddCode("ret\t$" + Core.Int32::ToString(context::firstReturnRegister) + ", $"
							+ Core.Int32::ToString(context::firstReturnRegister + currentMethod::returnTypes::.getSize() - 1));
					else
					{
						for (int32 i = 0; i < rnode::values::.getSize(); i = i + 1)
						{
							Node vnode = [Node] rnode::values[i];
							/* TODO: Type */
							CompileExpression(vnode, freereg + i, freereg + i, 0, 0)
								::ToRegister(this, freereg + i);
						}
						AddCode("ret\t$" + Core.Int32::ToString(freereg) + ", $"
							+ Core.Int32::ToString(freereg + rnode::values::.getSize() - 1));
					}
				}
			}
			return 1, freereg;
		}
		else if (node::op == Token::Continue)
		{
			if (context::loopLevel == 0)
				throw new CompilerException("Not in a loop.", node::location);
			int32 ctx = Core.Int32::Parse([Core.String] context::contextType::Peek());
			if (ctx == Context::Finally)
				throw new CompilerException("Control cannot go out of the finally block.", node::location);

			context::continueLabelId = FixJumpTarget(context::continueLabelId);
			if (ctx == Context::TryCatch)
				AddCode("leave\t" + GetLabelName(context::continueLabelId));
			else
				AddCode("jmp\t" + GetLabelName(context::continueLabelId));
			return 1, freereg;
		}
		else if (node::op == Token::Break)
		{
			if (context::loopLevel == 0)
				throw new CompilerException("Not in a loop.", node::location);
			int32 ctx = Core.Int32::Parse([Core.String] context::contextType::Peek());
			if (ctx == Context::Finally)
				throw new CompilerException("Control cannot go out of the finally block.", node::location);

			context::breakLabelId = FixJumpTarget(context::breakLabelId);
			if (ctx == Context::TryCatch)
				AddCode("leave\t" + GetLabelName(context::breakLabelId));
			else
				AddCode("jmp\t" + GetLabelName(context::breakLabelId));
			return 0, freereg;
		}
		else if (node::op == Token::Try)
		{
			TryNode tnode = [TryNode] node;
			int32 endTarget = currentLabelId;
			currentLabelId = currentLabelId + 1;

			if (tnode::finallyNode != null)
			{
				context::tryCatchLevel = context::tryCatchLevel + 1;
				context::contextType::Push([Core.Object] Core.Int32::ToString(Context::TryCatch));
			}

			AddCode(".try {");
			Tab();
			int32 closed = CompileStatement(tnode::body, freereg, context);
			if (closed == 0)
				if (tnode::finallyNode == null)
					AddCode("jmp\t" + GetLabelName(endTarget));
				else
					AddCode("leave\t" + GetLabelName(endTarget));
			Untab();
			AddCode("}");
			for (int32 i = 0; i < tnode::catchNodes::.getSize(); i = i + 1)
			{
				CatchNode cnode = [CatchNode] tnode::catchNodes[i];
				AddCode(".catch(" + ResolveType(cnode::type)::ToString()
					+ " $" + Core.Int32::ToString(freereg) + ") {");
				PushSymbolStack();
				Variable var = new Variable();
				var::regid = freereg;
				var::type = ResolveType(cnode::type);
				([Hash] symbolTable::Peek())::Add(cnode::name, [Core.Object] var);
				Tab();
				int32 closed = CompileStatement(cnode::body, freereg + 1, context);
				if (closed == 0)
					if (tnode::finallyNode == null)
						AddCode("jmp\t" + GetLabelName(endTarget));
					else
						AddCode("leave\t" + GetLabelName(endTarget));
				Untab();
				AddCode("}");
				PopSymbolStack(); 
			}
			if (tnode::finallyNode != null)
			{
				context::tryCatchLevel = context::tryCatchLevel - 1;
				context::contextType::Pop();
				context::finallyLevel = context::finallyLevel + 1;
				context::contextType::Push([Core.Object] Core.Int32::ToString(Context::Finally));

				AddCode(".finally {");
				Tab();
				CompileStatement(tnode::finallyNode, freereg, context);
				AddCode("endfinally");
				Untab();
				AddCode("}");

				context::contextType::Pop();
				context::finallyLevel = context::finallyLevel - 1;
			}
			AddLabel(endTarget);
			return 0, freereg;
		}
		else if (node::op == Token::Throw)
		{
			ThrowNode tnode = [ThrowNode] node;
			RegisterValue value = ToScalar(CompileList(tnode::exception, freereg, -1))::EnsureRegister(this, freereg);
			AddCode("throw\t$" + Core.Int32::ToString(value::regid));
			return 1, freereg;
		}
		else
		{
			CompileList(node, freereg, -1);
			return 0, freereg;
		}
	}

	/* Call node is the only 'expression'-like node that can return multiple values (or zero). */
	/* So don't bother mentioning it many times here */
	/* Save last scalar value to 'lastreg' if 'lastreg' != -1 */
	private function CompileList(Node node, int32 freereg, int32 lastreg) -> Vector
	{
		if (node::op == Token::List)
		{
			ListNode lnode = [ListNode] node;
			Vector ret = new Vector();
			for (int32 i = 0; i < lnode::values::.getSize(); i = i + 1)
			{
				Node node = [Node] lnode::values[i];
				int32 reg = freereg + ret::.getSize();
				if (node::op == Token::Call)
				{
					Vector r = CompileCall(node, reg);
					for (int32 j = 0; j < r::.getSize(); j = j + 1)
						ret::Add(r[j]);
				}
				else if (lastreg != -1 && i + 1 == lnode::values::.getSize()) /* Last scalar */
					ret::Add([Core.Object] CompileExpression(node, reg, lastreg, 0, 0)::EnsureRegister(this, lastreg));
				else /* Ensure value is a register at stack position */
					ret::Add([Core.Object] CompileExpression(node, reg, reg, 0, 0)::ToRegister(this, reg));
			}
			return ret;
		}
		else if (node::op == Token::Assign)
		{
			BinNode bnode = [BinNode] node;
			if (bnode::left::op != Token::List)
			{
				/* Single operand assign */
				Value l = CompileExpression(bnode::left, freereg, freereg, 0, 0);
				/* HACK: not */
				if (l is LValue)
				{}
				else
					throw new CompilerException("Lvalue expected.", bnode::left::location);
				LValue left = [LValue] l;

				freereg = l::GetNextFreeRegister(freereg);
				int32 targetreg = freereg;
				if (left is VariableValue)
					targetreg = ([VariableValue] left)::regid;
				Value right = CompileExpression(bnode::right, freereg, targetreg, 0, 0);
				right::ToLValue(this, node::location, left, freereg);
				return Scalar(left);
			}
			else
			{
				Vector left = new Vector();
				ListNode lnode = [ListNode] bnode::left;
				for (int32 i = 0; i < lnode::values::.getSize(); i = i + 1)
				{
					Value value = CompileExpression([Node] lnode::values[i], freereg, freereg, 0, 0);
					freereg = value::GetNextFreeRegister(freereg);
					/* HACK: not */
					if (value is LValue)
					{}
					else
						throw new CompilerException("Lvalue expected.", node::location);
					left::Add([Core.Object] value);
				}

				/* Optimize: if last element of 'left' is a variable,
				   directly store corresponding result in 'right' to that register */
				if (left[left::.getSize() - 1] is VariableValue)
					lastreg = ([VariableValue] left[left::.getSize() - 1])::regid;
				else
					lastreg = -1;
				Vector right = CompileList(bnode::right, freereg, lastreg);
				if (left::.getSize() != right::.getSize())
					throw new CompilerException("List size unmatch.", node::location);
				/* Move results to left, note the last one must be copied first, due to the optimization above */
				for (int32 i = left::.getSize() - 1; i >= 0; i = i - 1)
					([Value] right[i])::ToLValue(this, node::location, [LValue] left[i], freereg);
				return left;
			}
		}
		else if (node::op == Token::Call)
			return CompileCall(node, freereg);
		else /* Scalar */
		{
			if (lastreg != -1)
				return Scalar(CompileExpression(node, freereg, lastreg, 0, 0));
			else
				return Scalar(CompileExpression(node, freereg, freereg, 0, 0));
		}
	}

	private function FixJumpTarget(int32 jtarget) -> int32
	{
		if (jtarget == 0)
		{
			currentLabelId = currentLabelId + 1;
			return currentLabelId - 1;
		}
		else
			return jtarget;
	}

	/* Convert types to a unified stack type for doing arithmetic */
	private function UnifyTypes(Node node, Value left, Value right, int32 leftreg, int32 rightreg) -> TypedValue, TypedValue
	{
		/* TODO: Immediate value */
		Type type;

		if (left::CanImplicitlyConvertTo(Type::Int8) > 0 && right::CanImplicitlyConvertTo(Type::Int8) > 0)
			type = Type::Int8;
		else if (left::CanImplicitlyConvertTo(Type::UInt8) > 0 && right::CanImplicitlyConvertTo(Type::UInt8) > 0)
			type = Type::UInt8;
		else if (left::CanImplicitlyConvertTo(Type::Int16) > 0 && right::CanImplicitlyConvertTo(Type::Int16) > 0)
			type = Type::Int16;
		else if (left::CanImplicitlyConvertTo(Type::UInt16) > 0 && right::CanImplicitlyConvertTo(Type::UInt16) > 0)
			type = Type::UInt16;
		else if (left::CanImplicitlyConvertTo(Type::Int32) > 0 && right::CanImplicitlyConvertTo(Type::Int32) > 0)
			type = Type::Int32;
		else if (left::CanImplicitlyConvertTo(Type::UInt32) > 0 && right::CanImplicitlyConvertTo(Type::UInt32) > 0)
			type = Type::UInt32;
		else
			throw new CompilerException("Uncompatible types.", node::location);

		TypedValue l = left::ToTyped(this, node::location, leftreg, type);
		TypedValue r = right::ToTyped(this, node::location, rightreg, type);

		return l, r;
	}

	/* Convert to a typed value from its corresponding raw stack value */
	private function FixRawValue(RegisterValue value, int32 targetreg) -> RegisterValue
	{
		/* TODO: Immediate value */
		Type stackType = value::type::.getStackType();
		if (value::type::Equals(stackType) == 0)
		{
			RegisterValue ret = value::EnsureRegister(this, targetreg);
			AddCode("conv\t" + value::type::ToString() + " $" + Core.Int32::ToString(targetreg) + ", "
				+ stackType::ToString() + " $" + Core.Int32::ToString(value::regid));
			value::regid = targetreg;
			return value;
		}
		else
			return value;
	}

	/* Return 'value' */
	private function CompileExpression(Node node, int32 freereg, int32 targetreg, int32 jtarget, int32 jtrue) -> Value
	{
		if (node::op <= Token::BinArith)
		{
			BinNode bnode = [BinNode] node;
			RegisterValue left = CompileExpression(bnode::left, freereg, freereg, 0, 0)::EnsureRegister(this, freereg);
			Value right = CompileExpression(bnode::right, freereg + 1, freereg + 1, 0, 0);
			Core.String inst;

			/* TODO */
			if ((left::type is IntType || left::type is PointerType) &&
				(right is IntegerValue || (right is TypedValue && ([TypedValue] right)::type is Int32Type)))
			{
				right = right::EnsureRegister(this, freereg + 1);
				if (left::type is PointerType)
				{
					Type valueType = ([PointerType] left::type)::.getValueType();

					RegisterValue ret = new RegisterValue(targetreg, left::type);
					AddCode("addp\t$" + Core.Int32::ToString(targetreg) + ", $" + Core.Int32::ToString(left::regid) + ", $"
						+ Core.Int32::ToString(([RegisterValue] right)::regid) + ", " + valueType::ToString());
					return ret;
				}
				if (bnode::op == Token::Add)
					inst = "addni";
				else if (bnode::op == Token::Sub)
					inst = "subni";
				else
					throw new CompilerException("Unsupported binary operatior.", node::location);
			}
			/* HACK: not */
			/* TODO */
			else if (left::type is PrimitiveType &&
				(right is ImmediateValue || (right is TypedValue && ([TypedValue] right)::type is PrimitiveType)))
			{
				if (bnode::op == Token::Add)
					inst = "add";
				else if (bnode::op == Token::Sub)
					inst = "sub";
				else if (bnode::op == Token::Mul)
					inst = "mul";
				else if (bnode::op == Token::Div)
					inst = "div";
				else if (bnode::op == Token::Rem)
					inst = "rem";
				else if (bnode::op == Token::BitAnd)
					inst = "and";
				else if (bnode::op == Token::BitOr)
					inst = "or";
				else if (bnode::op == Token::BitXor)
					inst = "xor";
				else
					throw new CompilerException("Unsupported binary operatior.", node::location);
				Value l;
				l, right = UnifyTypes(node, left, right, freereg, freereg + 1);
				left = l::EnsureRegister(this, freereg);
				inst = inst + left::type::.getStackType()::.getSuffix();
			}
			else
				return CompileCustomBinaryOperator(node, bnode::op, left, [TypedValue] right, freereg);

			RegisterValue ret = new RegisterValue(targetreg, left::type);
			
			/* TODO */
			if (right is IntegerValue && left::type is Int32Type)
				AddCode(inst + "\t$" + Core.Int32::ToString(targetreg)
					+ ", $" + Core.Int32::ToString(left::regid)
					+ ", " + ([IntegerValue] right)::value);
			else
			{
				AddCode(inst + "\t$" + Core.Int32::ToString(targetreg)
					+ ", $" + Core.Int32::ToString(left::regid)
					+ ", $" + Core.Int32::ToString(right::EnsureRegister(this, freereg + 1)::regid));
				ret = FixRawValue(ret, targetreg);
			}
			return ret;
		}
		else if (node::op <= Token::BinComparison)
		{
			jtarget = FixJumpTarget(jtarget);

			BinNode bnode = [BinNode] node;
			RegisterValue left = CompileExpression(bnode::left, freereg, freereg, 0, 0)::EnsureRegister(this, freereg);
			Value right = CompileExpression(bnode::right, freereg + 1, freereg + 1, 0, 0);
			Core.String inst;
			/* TODO */
			if ((left::type is Int32Type || left::type is CharType)
				&& (right is IntegerValue || (right is TypedValue && left::type::Equals(([TypedValue] right)::type) > 0)))
			{
				if (jtrue > 0) /* jump on true */
				{
					if (bnode::op == Token::LT)
						inst = "lt";
					else if (bnode::op == Token::LE)
						inst = "le";
					else if (bnode::op == Token::GT)
						inst = "gt";
					else if (bnode::op == Token::GE)
						inst = "ge";
					else if (bnode::op == Token::EQ)
						inst = "eq";
					else if (bnode::op == Token::NEQ)
						inst = "neq";
					else
						throw new CompilerException("Unsupported comparison operatior.", node::location);
				}
				else /* jump on false */
				{
					if (bnode::op == Token::LT)
						inst = "ge";
					else if (bnode::op == Token::LE)
						inst = "gt";
					else if (bnode::op == Token::GT)
						inst = "le";
					else if (bnode::op == Token::GE)
						inst = "lt";
					else if (bnode::op == Token::EQ)
						inst = "neq";
					else if (bnode::op == Token::NEQ)
						inst = "eq";
					else
						throw new CompilerException("Unsupported comparison operatior.", node::location);
				}
				if (right is IntegerValue && ([IntegerValue] right)::value::Equals("0") > 0)
					AddCode("j" + inst + "zi\t$" + Core.Int32::ToString(left::regid) + ", " + GetLabelName(jtarget));
				else
				{
					RegisterValue r = right::EnsureRegister(this, freereg + 1);
					AddCode("j" + inst + "i\t$" + Core.Int32::ToString(left::regid) + ", $"
						+ Core.Int32::ToString(r::regid) + ", " + GetLabelName(jtarget));
				}
			}
			/* HACK: not */
			/* HACK: null */
			else if ((left::type is IntType || left::type is ArrayType || left::type is ClassType)
				&& right is NullValue)
			{
				if (jtrue > 0) /* jump on true */
					if (bnode::op == Token::EQ)
						inst = "jn";
					else if (bnode::op == Token::NEQ)
						inst = "jnn";
					else
						throw new CompilerException("Unsupported comparison operatior.", node::location);
				else /* jump on false */
					if (bnode::op == Token::EQ)
						inst = "jnn";
					else if (bnode::op == Token::NEQ)
						inst = "jn";
					else
						throw new CompilerException("Unsupported comparison operatior.", node::location);
				AddCode(inst + "\t$" + Core.Int32::ToString(left::regid) + ", " + GetLabelName(jtarget));
			}
			else if (bnode::op == Token::Is)
			{
				/* HACK: not */
				if (right is TypeValue)
				{}
				else
					throw new CompilerException("Not a type.", node::location);
				if (jtrue > 0) /* jump on true */
					inst = "jinst";
				else /* jump on false */
					inst = "jninst";
				AddCode(inst + "\t$" + Core.Int32::ToString(left::regid) + ", " + ([TypeValue] right)::type::ToString()
					+ ", " + GetLabelName(jtarget));
			}
			else
				throw new CompilerException("Unhandled jcc case.", node::location);
			return new JumpTargetValue(jtarget);
		}
		else if (node::op <= Token::BinLogic)
		{
			jtarget = FixJumpTarget(jtarget);

			BinNode bnode = [BinNode] node;
			int32 leftjtrue, rightjtrue;
			int32 leftjtarget, rightjtarget;
			/* Calculate jump target of left/right */
			if (node::op == Token::And)
			{
				if (jtrue > 0)
				{
					leftjtrue = 0;
					leftjtarget = currentLabelId;
					rightjtrue = 1;
					rightjtarget = jtarget;
					currentLabelId = currentLabelId + 1;
				}
				else
				{
					leftjtrue = 0;
					rightjtrue = 0;
					leftjtarget = rightjtarget = jtarget;
				}
			}
			else if (node::op == Token::Or)
			{
				if (jtrue > 0)
				{
					leftjtrue = 1;
					rightjtrue = 1;
					leftjtarget = rightjtarget = jtarget;
				}
				else
				{
					leftjtrue = 1;
					leftjtarget = currentLabelId;
					rightjtrue = 0;
					rightjtarget = jtarget;
					currentLabelId = currentLabelId + 1;
				}
			}
			else
				throw new Core.InvalidOperationException();
			CompileExpression(bnode::left, freereg, freereg, leftjtarget, leftjtrue)
				::ToJumpTarget(this, bnode::left::location, freereg, leftjtarget, leftjtrue);
			CompileExpression(bnode::right, freereg, freereg, rightjtarget, rightjtrue)
				::ToJumpTarget(this, bnode::right::location, freereg, rightjtarget, rightjtrue);
			if (leftjtarget != jtarget)
				AddLabel(leftjtarget);

			return new JumpTargetValue(jtarget);
		}
		else if (node::op <= Token::UnaryOp)
		{
			UnaryNode unode = [UnaryNode] node;
			if (node::op == Token::Deref)
			{
				/* Deference */
				RegisterValue value = CompileExpression(unode::operand, freereg, freereg, 0, 0)::EnsureRegister(this, freereg);
				if (value::type is IntType)
					return new DerefValue(value::regid, Type::Char);
				else if (value::type is PointerType)
					return new DerefValue(value::regid, ([PointerType] value::type)::.getValueType());
				else
					throw new CompilerException("Not a pointer.", node::location);
			}
			else if (node::op == Token::AddressOf)
			{
				Value value = CompileExpression(unode::operand, freereg, freereg, 0, 0);
				/* TODO */
				Type type;
				if (value is VariableValue)
				{
					VariableValue v = [VariableValue] value;
					AddCode("lar\t$" + Core.Int32::ToString(targetreg) + ", $" + Core.Int32::ToString(v::regid));
					type = v::type;
				}
				else if (value is FieldValue)
				{
					FieldValue v = [FieldValue] value;
					Field field = v::field;
					if (field::modifier & Modifier::Static > 0)
						AddCode("las\t$" + Core.Int32::ToString(targetreg) + ", " + field::classObject::name
							+ "::" + field::name);
					else
						AddCode("laf\t$" + Core.Int32::ToString(targetreg) + ", $" + Core.Int32::ToString(v::regid)
							+ ", " + field::classObject::name + "::" + field::name);
					type = v::type;
				}
				else if (value is ArrayElementValue)
				{
					ArrayElementValue v = [ArrayElementValue] value;
					AddCode("lae\t$" + Core.Int32::ToString(targetreg) + ", $" + Core.Int32::ToString(v::regid)
						+ "($" + Core.Int32::ToString(v::regid2) + ")");
					type = v::type;
				}
				else
					throw new CompilerException("LValue expected.", node::location);
				return new RegisterValue(targetreg, [Type] new PointerType(type)); /* HACK: .ctor overload */
			}
			else
			{
				RegisterValue value = CompileExpression(unode::operand, freereg, targetreg, 0, 0)::EnsureRegister(this, targetreg);
				/* HACK: not */
				if (value::type is Int32Type)
				{
					Core.String inst;
					if (node::op == Token::Neg)
						inst = "negi";
					else if (node::op == Token::BitNot)
						inst = "noti";
					else
						throw new CompilerException("Unsupported unary operatior.", node::location);
					AddCode(inst + "\t$" + Core.Int32::ToString(targetreg) + ", $" + Core.Int32::ToString(value::regid));
					return new RegisterValue(targetreg, value::type);
				}
				else
					throw new CompilerException("Int32 expected.", node::location); /* TODO */
			}
		}
		else if (node::op == Token::New)
		{
			NewNode nnode = [NewNode] node;
			Type t = ResolveType(nnode::type);
			/* HACK: not */
			if (t is ClassType)
			{}
			else
				throw new CompilerException("Not a class type", nnode::location);
			ClassType type = [ClassType] t;
			Class classObject = type::.getClass();
			/* HACK */
			Vector methods = ResolveMethodInClass(classObject, ".ctor", null);
			Vector values = new Vector();
			for (int32 i = 0; i < nnode::parameters::.getSize(); i = i + 1)
			{
				Value value = ToScalar(CompileList([Node] nnode::parameters[i], freereg + 2 + i, -1));
				values::Add(value::EnsureSingleSlot(this, freereg + 2 + i));
			}
			Method method = PrepareCall(nnode, methods, values, freereg + 2);
			AddCode("new\t$" + Core.Int32::ToString(freereg) + ", " + classObject::name + "::"
				+ method::name + ResolvePrototype(method));
			return new RegisterValue(freereg, [Type] type); /* HACK: .ctor overload */
		}
		else if (node::op == Token::NewArray)
		{
			NewNode nnode = [NewNode] node;
			if (nnode::parameters::.getSize() != 1)
				throw new CompilerException("Currently only 1 dim array supported.", node::location);

			RegisterValue value = ToScalar(CompileList([Node] nnode::parameters[0], freereg, -1))::ToRegister(this, freereg);
			Type elementType = ResolveType(nnode::type);
			AddCode("newarr\t$" + Core.Int32::ToString(targetreg) + ", " + elementType::ToString()
				+ "($" + Core.Int32::ToString(value::regid) + ")");
			return new RegisterValue(targetreg, [Type] new ArrayType(elementType)); /* HACK: .ctor overload */
		}
		else if (node::op == Token::Call)
			return ToScalar(CompileCall(node, freereg));
		else if (node::op == Token::Assign)
			return ToScalar(CompileList(node, freereg, -1));
		else if (node::op == Token::TypeCast)
		{
			TypeCastNode tnode = [TypeCastNode] node;
			RegisterValue value = CompileExpression(tnode::operand, freereg, targetreg, 0, 0)::EnsureRegister(this, targetreg);
			/* HACK: Workaround */
			if (value::type is PointerType && ResolveType(tnode::type) is IntType)
			{
				value::type = Type::Int;
				return value;
			}
			else if (value::type is PrimitiveType)
			{
				/* No boxing/unboxing now */
				if (ResolveType(tnode::type) is PrimitiveType)
				{
					value::type = ResolveType(tnode::type);
					return value;
				}
				else
					throw new CompilerException("No boxing/unboxing now.", node::location);
			}
			else
			{
				Type type = ResolveType(tnode::type);
				AddCode("cast\t$" + Core.Int32::ToString(targetreg) + ", $" + Core.Int32::ToString(value::regid)
					+ ", " + type::ToString());
				return new RegisterValue(targetreg, type);
			}
		}
		else if (node::op == Token::ArrayElement)
		{
			ArrayElementNode anode = [ArrayElementNode] node;
			RegisterValue array = ToScalar(CompileList(anode::array, freereg, -1))::EnsureRegister(this, freereg);
			if (array::type is ArrayType)
			{
				freereg = array::GetNextFreeRegister(freereg);
				RegisterValue index = ToScalar(CompileList(anode::index, freereg, -1))::EnsureRegister(this, freereg);
				return new ArrayElementValue(array::regid, index::regid, ([ArrayType] array::type)::.getElementType());
			}
			else
			{
				RegisterValue index = CompileExpression(anode::index, freereg + 1, freereg + 1, 0, 0)
					::EnsureRegister(this, freereg + 1);
				return CompileCustomBinaryOperator(node, Token::Array, array, index, freereg);
			}
		}
		else if (node::op == Token::Field)
		{
			FieldNode fnode = [FieldNode] node;
			Value object = CompileExpression(fnode::object, freereg, freereg, 0, 0);
			/* TODO */
			if (object is TypedValue && ([TypedValue] object)::type is ArrayType)
			{
				if (fnode::field::Equals("Length") == 0)
					throw new CompilerException("Unknown field.", node::location);
				RegisterValue v = object::EnsureRegister(this, freereg);
				AddCode("ldlen\t$" + Core.Int32::ToString(targetreg) + ", $" + Core.Int32::ToString(v::regid));
				return new RegisterValue(targetreg, Type::Int32);
			}

			int32 regid;
			Type type = Type::Unit;
			Class classObject;
			if (object is TypeValue)
				type = ([TypeValue] object)::type;
			else if (object is TypedValue)
			{
				RegisterValue v = object::EnsureRegister(this, freereg);
				type = ([TypedValue] object)::type;
				regid = v::regid;
			}

			/* HACK: not */
			if (type is ClassType)
				classObject = ([ClassType] type)::.getClass();
			else
				throw new CompilerException("Not an object or class.", fnode::object::location);

			Field field = ResolveField(classObject, fnode::field);
			if (field != null)
				return new FieldValue(regid, field, ResolveType(field::type));
			else
			{
				/* HACK */
				Vector methods = new Vector();
				ResolveMethod(classObject, fnode::field, methods);
				if (methods::.getSize() == 0)
					throw new CompilerException("Unknown field.", node::location);
				return new MethodValue(regid, methods);
			}
		}
		else if (node::op == Token::Ident)
		{
			IdentNode inode = [IdentNode] node;
			int32 found;
			Core.Object classObject;
			if ((found, classObject = classes::Contains(inode::ident)) > 0)
				return new TypeValue([Type] new ClassType([Class] classObject)); /* HACK: .ctor overload */
			else
			{
				Variable variable;
				int32 found;
				variable, found = FindSymbol(inode::ident);
				if (found > 0)
					return new VariableValue(variable::regid, variable::type);
				else
				{
					Field field = ResolveField(currentClass, inode::ident);
					if (field != null)
						return new FieldValue(0, field, ResolveType(field::type));
					else
					{
						/* HACK */
						Vector methods = new Vector();
						ResolveMethod(currentClass, inode::ident, methods);
						if (methods::.getSize() == 0)
							throw new CompilerException("Unknown ident.", node::location);
						return new MethodValue(0, methods);
					}
				}
			}
		}
		else if (node::op == Token::This)
		{
			if (currentMethod::modifier & Modifier::Static > 0)
				throw new CompilerException("'this' cannot be used in a static method.", node::location);
			return new RegisterValue(0, [Type] new ClassType(currentClass)); /* HACK: .ctor overload */
		}
		else if (node::op == Token::Number)
		{
			IntegerNode inode = [IntegerNode] node;
			return new IntegerValue(inode::intvalue);
		}
		else if (node::op == Token::String)
		{
			/* TODO: StringValue */
			StringNode snode = [StringNode] node;
			AddCode("ldstr\t$" + Core.Int32::ToString(targetreg) + ", \"" + snode::stringvalue + "\"");
			return new RegisterValue(targetreg, [Type] new ClassType([Class] classes["Core.String"])); /* HACK: .ctor overload */
		}
		else if (node::op == Token::Null)
			return new NullValue();
		else if (node::op == Token::Bool)
			return new BoolValue(([BoolNode] node)::boolvalue);
		else
			throw new CompilerException("INTERNAL: Unhandled expression case.", node::location);
	}

	private function CompileCall(Node node, int32 freereg) -> Vector
	{
		CallNode cnode = [CallNode] node;
		Value methodValue = ToScalar(CompileList(cnode::method, freereg, -1));
		/* HACK: not */
		if (methodValue is MethodValue)
		{}
		else
			throw new CompilerException("Method expected.", cnode::method::location);
		Vector methods = ([MethodValue] methodValue)::methods;
		Class classObject = ([Method] methods[0])::classObject;

		/* Push 'this' if necessary */
		/* TODO: We do not allow overload mixed static/unstatic methods */
		int32 firstreg = freereg;
		if (([Method] methods[0])::modifier & Modifier::Static > 0)
			firstreg = freereg;
		else
		{
			/* HACK: .ctor overload */
			(new RegisterValue(([MethodValue] methodValue)::regid, [Type] new ClassType(classObject)))::ToRegister(this, freereg);
			firstreg = firstreg + 1;
		}

		/* Evaluate parameters */
		Vector values = new Vector();
		for (int32 i = 0; i < cnode::parameters::.getSize(); i = i + 1)
		{
			Value value = ToScalar(CompileList([Node] cnode::parameters[i], firstreg + i, -1));
			values::Add([Core.Object] value::EnsureSingleSlot(this, firstreg + i));
		}

		Method method = PrepareCall(node, methods, values, firstreg);

		/* Call function */
		Core.String inst;
		if (method::modifier & Modifier::Virtual > 0 || method::modifier & Modifier::Abstract > 0)
			inst = "callv";
		else
			inst = "call";
		AddCode(inst + "\t$" + Core.Int32::ToString(freereg) + ", " + classObject::name + "::"
			+ method::name + ResolvePrototype(method));

		/* Return value */
		Vector ret = new Vector();
		for (int32 i = 0; i < method::returnTypes::.getSize(); i = i + 1)
			ret::Add([Core.Object] new RegisterValue(freereg + i, ResolveType([ParserType] method::returnTypes[i])));
		return ret;
	}

	private function CompileCustomBinaryOperator(Node node, int32 op, TypedValue left, TypedValue right, int32 firstreg) -> Value
	{
		TypedValue l = left::EnsureSingleSlot(this, firstreg);
		TypedValue r = right::EnsureSingleSlot(this, firstreg + 1);

		Core.String methodName = GetOperatorMethodName(op);
		if (methodName == null)
			throw new CompilerException("Unsupported operator.", node::location);

		Vector methods = new Vector();
		if (l::type is ClassType)
			ResolveMethod(([ClassType] l::type)::.getClass(), methodName, methods);
		if (r::type is ClassType)
			ResolveMethod(([ClassType] r::type)::.getClass(), methodName, methods);

		Vector values = new Vector();
		values::Add(l);
		values::Add(r);

		Method method = PrepareCall(node, methods, values, firstreg);
		AddCode("call\t$" + Core.Int32::ToString(firstreg) + ", " + method::classObject::name + "::"
			+ methodName + ResolvePrototype(method));
		return new RegisterValue(firstreg, ResolveType([ParserType] method::returnTypes[0]));
	}

	/* Resolves a type from standarized type string */
	private function ResolveParserType(Location location, Core.String type) -> Type
	{
		if (type::Equals("bool") > 0)
			return Type::Bool;
		else if (type::Equals("int8") > 0)
			return Type::Int8;
		else if (type::Equals("uint8") > 0)
			return Type::UInt8;
		else if (type::Equals("int16") > 0)
			return Type::Int16;
		else if (type::Equals("uint16") > 0)
			return Type::UInt16;
		else if (type::Equals("int32") > 0)
			return Type::Int32;
		else if (type::Equals("uint32") > 0)
			return Type::UInt32;
		else if (type::Equals("char") > 0)
			return Type::Char;
		else if (type::Equals("int") > 0)
			return Type::Int;
		else if (type::SubString(type::.getLength() - 2, 2)::Equals("[]") > 0)
			return new ArrayType(ResolveParserType(location, type::SubString(0, type::.getLength() - 2)));
		else if (type::SubString(type::.getLength() - 1, 1)::Equals("*") > 0)
			return new PointerType(ResolveParserType(location, type::SubString(0, type::.getLength() - 1)));
		else
		{
			Core.Object c;
			int32 found;
			found, c = classes::Contains(type);
			if (found == 0)
				throw new CompilerException("Unknown type \"" + type + "\".", location);
			return new ClassType([Class] c);
		}
	}

	private function ResolveType(ParserType type) -> Type
	{
		if (type::type == null)
			type::type = ResolveParserType(type::location, type::typestring);
		return type::type;
	}

	private function ResolvePrototype(Method method) -> Core.String
	{
		if (method::prototype == null)
		{
			/* Concatenate prototype string */
			Core.String prototype = "(";
			for (int32 i = 0; i < method::paramTypes::.getSize(); i = i + 1)
			{
				if (i == 0)
					prototype = prototype + ResolveType([ParserType] method::paramTypes[i])::ToString();
				else
					prototype = prototype + ", " + ResolveType([ParserType] method::paramTypes[i])::ToString();
			}
			prototype = prototype + ")";
			if (method::returnTypes::.getSize() > 0)
			{
				prototype = prototype + " -> ";
				for (int32 i = 0; i < method::returnTypes::.getSize(); i = i + 1)
				{
					if (i == 0)
						prototype = prototype + ResolveType([ParserType] method::returnTypes[i])::ToString();
					else
						prototype = prototype + ", " + ResolveType([ParserType] method::returnTypes[i])::ToString();
				}
			}
			method::prototype = prototype;
		}
		return method::prototype;
	}

	/* Returns field and corresponding class which the field is defined in */
	private function ResolveField(Class startClass, Core.String name) -> Field
	{
		Class c = startClass;
		while (c != null)
		{
			Core.Object field;
			int32 found;
			if ((found, field = c::fields::Contains(name)) > 0)
				return [Field] field;
			c = c::baseClass;
		}
		return null;
	}

	/* Resolves a method by name, append possible candidates to `methods` vector */
	private function ResolveMethod(Class startClass, Core.String name, Vector methods) -> Vector
	{
		if (methods == null)
			methods = new Vector();
		Class c = startClass;
		while (c != null)
		{
			ResolveMethodInClass(c, name, methods);
			c = c::baseClass;
		}
		return methods;
	}

	/* Resolves a method in a single class */
	private function ResolveMethodInClass(Class classObject, Core.String name, Vector methods) -> Vector
	{
		if (methods == null)
			methods = new Vector();
		Vector current = classObject::methods::FindAll(name);
		for (int32 i = 0; i < current::.getSize(); i = i + 1)
		{
			Method method = [Method] current[i];
			if (method::modifier & Modifier::Override == 0) /* Do not include overridden methods */
			{
				/* HACK: bool */
				int32 ok = 1;
				/* Make sure this method is not overridden by a subclass method */
				for (int32 j = 0; j < methods::.getSize(); j = j + 1)
				{
					Method another = [Method] methods[j];
					if (ResolvePrototype(method)::Equals(ResolvePrototype(another)) > 0)
					{
						ok = 0;
						break;
					}
				}
				if (ok > 0)
					methods::Add([Core.Object] method);
			}
		}
		return methods;
	}

	/* Choose best method in `methods`,
	   Ensures `values` are converted to proper types and placed sequentially from `firstreg`
	   Returns best method */
	private function PrepareCall(Node node, Vector methods, Vector values, int32 firstreg) -> Method
	{
		Vector candidates = new Vector();
		/* Check valid candidates */
		for (int32 i = 0; i < methods::.getSize(); i = i + 1)
		{
			Method method = [Method] methods[i];
			if (method::paramTypes::.getSize() == values::.getSize())
			{
				/* HACK: bool */
				int32 ok = 1;
				for (int32 j = 0; j < method::paramTypes::.getSize(); j = j + 1)
					if (([Value] values[j])::CanImplicitlyConvertTo(ResolveType([ParserType] method::paramTypes[j])) == 0)
					{
						ok = 0;
						break;
					}
				if (ok > 0)
					candidates::Add([Core.Object] method);
			}
		}
		Method method = ChooseBestMethod(node, candidates, values);
		/* Prepare values */
		for (int32 i = 0; i < values::.getSize(); i = i + 1)
			([Value] values[i])::ToTypedRegister(
				this, node::location, firstreg + i, ResolveType([ParserType] method::paramTypes[i])
			);
		return method;
	}

	/* S = Given type, T1 = Method 1 type, T2 = Method 2 type
	 * `->` means implicitly convertible
	 * Rules:
	 * 1. If T1 = T2, neither is better.
	 * 2. If S = T1, T1 is better.
	 *    If S = T2, T2 is better.
	 * 3. If T1 -> T2 and not T2 -> T1, T1 is beter.
	 *    If T2 -> T1 and not T1 -> T2, T2 is better.
	 * 4. Otherwise, neither is better.
	 */
	private function ChooseBestMethod(Node node, Vector methods, Vector values) -> Method
	{
		if (methods::.getSize() == 0)
			throw new CompilerException("No method prototype match type of given parameters.", node::location);
		for (int32 i = 0; i < methods::.getSize(); i = i + 1)
		{
			Method current = [Method] methods[i];
			/* HACK: bool */
			int32 ok = 1;
			for (int32 j = 0; j < methods::.getSize(); j = j + 1)
				if (i != j)
				{
					Method another = [Method] methods[j];
					/* HACK: bool */
					int32 better = 0;
					for (int32 k = 0; k < values::.getSize(); k = k + 1)
					{
						Type S = Type::Unit;
						if (values[k] is TypedValue)
							S = ([TypedValue] values[k])::type;
						Type T1 = ResolveType([ParserType] current::paramTypes[k]);
						Type T2 = ResolveType([ParserType] another::paramTypes[k]);
						if (T1::Equals(T2) > 0)
							continue;
						if (S::Equals(T1) > 0)
						{
							better = 1;
							continue;
						}
						if (S::Equals(T2) > 0)
						{
							better = 0;
							break;
						}
						/* HACK: bool */
						int32 c1 = T1::CanImplicitlyConvertTo(T2), c2 = T2::CanImplicitlyConvertTo(T1);
						if (c1 > 0 && c2 == 0)
							better = 1;
						else if (c1 == 0 && c2 > 0)
						{
							better = 0;
							break;
						}
					}
					/* Best method must be better than any other method */
					if (better == 0)
					{
						ok = 0;
						break;
					}
				}
			if (ok > 0)
				return current;
		}
		throw new CompilerException("Ambiguous function call.", node::location);
	}
}
