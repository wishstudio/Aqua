class CompilerException
{
	public Core.String message;
	public Location location;

	public (Core.String message, Location location)
	{
		this::message = message;
		this::location = location;
	}

	public ToString() -> Core.String
	{
		return location::ToString() + ": " + message;
	}
}

class Variable
{
	public int32 regid;
	public Type type;
}

class Context
{
	public static int32 Loop, TryCatch, Finally;

	public int32 loopLevel, tryCatchLevel, finallyLevel;
	public int32 continueLabelId;
	public int32 breakLabelId;
	public int32 firstReturnRegister;
	public Stack contextType;
	/* HACK: bool */
	public int32 generateEpilogue;

	public ()
	{
		contextType = new Stack();
	}

	public static InitContext()
	{
		Context::Loop, Context::TryCatch, Context::Finally = 1, 2, 3;
	}
}

class Compiler
{
	private Hash classes;

	public Vector code;
	private int32 tab;
	private Stack symbolTable; /* Stack of symbol hashes */
	private Class currentClass;
	private Method currentMethod;
	private int32 currentLabelId;

	public Hash Classes
	{
		get { return classes; }
	}

	public Class CurrentClass
	{
		get { return currentClass; }
	}

	public Method CurrentMethod
	{
		get { return currentMethod; }
	}

	public (Hash classes)
	{
		this::classes = classes;
		code = new Vector();
		symbolTable = new Stack();
	}

	private GetLabelName(int32 labelId) -> Core.String
	{
		return "_L" + labelId;
	}

	private GetNextLabelId() -> int32
	{
		currentLabelId = currentLabelId + 1;
		return currentLabelId - 1;
	}

	private AddCode(Core.String line)
	{
		Core.String tabs = "";
		for (int32 i = 0; i < tab; i = i + 1)
			tabs = tabs + "\t";
		code::Add([Core.Object] (tabs + line));
	}

	private AddLabel(int32 labelId)
	{
		code::Add([Core.Object] (GetLabelName(labelId) + ":"));
	}

	private AddStringLabel(Core.String label)
	{
		code::Add([Core.Object] (label + ":"));
	}

	private Tab()
	{
		tab = tab + 1;
	}

	private Untab()
	{
		tab = tab - 1;
	}

	private PushSymbolStack()
	{
		symbolTable::Push([Core.Object] new Hash());
	}

	private PopSymbolStack()
	{
		symbolTable::Pop();
	}

	private FindSymbol(Core.String name) -> Variable, int32
	{
		for (int32 i = symbolTable::Size - 1; i >= 0; i = i - 1)
		{
			int32 found;
			Core.Object ret;
			if ((found, ret = ([Hash] symbolTable::data[i])::Contains(name)) > 0)
				return [Variable] ret, 1;
		}
		return null, 0;
	}

	public static GetOperatorMethodName(int32 op) -> Core.String
	{
		if (op == Token::Add)
			return ".opAdd";
		else if (op == Token::Sub)
			return ".opSub";
		else if (op == Token::Mul)
			return ".opMul";
		else if (op == Token::Div)
			return ".opDiv";
		else if (op == Token::Rem)
			return ".opRem";
		else if (op == Token::LT)
			return ".opLT";
		else if (op == Token::LE)
			return ".opLE";
		else if (op == Token::GT)
			return ".opGT";
		else if (op == Token::GE)
			return ".opGE";
		else if (op == Token::EQ)
			return ".opEQ";
		else if (op == Token::NEQ)
			return ".opNEQ";
		else if (op == Token::Array)
			return ".opArrayElement";
		else
			return null;
	}

	public GetMethodSignature(Method method) -> Core.String
	{
		return method::classObject::name + "::" + method::name + ResolvePrototype(method);
	}
	
	private ToScalar(Vector values) -> Value
	{
		if (values::Size == 0)
			throw new Core.Exception(); /* TODO */
		return [Value] values[0];
	}

	private Scalar(Value value) -> Vector
	{
		Vector ret = new Vector();
		ret::Add([Core.Object] value);
		return ret;
	}

	public Compile()
	{
		/* Set class::baseClass */
		/* HACK: iterator */
		for (int32 i = 0; i < classes::Size; i = i + 1)
		{
			Class current = [Class] classes::values[i];
			if (current::baseName::Equals("") == 0)
			{
				Core.Object baseClass;
				int32 found;
				found, baseClass = classes::Contains(current::baseName);
				if (found == 0)
					throw new CompilerException("Unknown base class \"" + current::baseName + "\".", current::location);
				current::baseClass = [Class] baseClass;
			}
		}

		tab = 0;
		Vector classes = this::classes::values;
		for (int32 i = 0; i < classes::Size; i = i + 1)
		{
			currentClass = [Class] classes[i];
			if (currentClass::baseClass == null)
				AddCode(".class " + currentClass::name);
			else
				AddCode(".class " + currentClass::name + ": " + currentClass::baseClass::name);
			AddCode("{");
			Tab();

			Vector fields = currentClass::fields::values;
			for (int32 j = 0; j < fields::Size; j = j + 1)
				CompileField([Field] fields[j]);

			Vector properties = currentClass::properties::values;
			for (int32 j = 0; j < properties::Size; j = j + 1)
				CompileProperty([Property] properties[j]);

			Vector methods = currentClass::methods::values;
			for (int32 j = 0; j < methods::Size; j = j + 1)
				CompileMethod([Method] methods[j]);

			Untab();
			AddCode("}");
		}
	}

	private CompileField(Field field)
	{
		Core.String modifier = Modifier::ToString(field::modifier);
		if (modifier::Length > 0)
			modifier = modifier + " ";
		AddCode(".field " + modifier + ResolveType(field::type)::ToString() + " " + field::name);
	}

	private CompileProperty(Property property)
	{
		Core.String modifier = Modifier::ToString(property::modifier);
		if (modifier::Length > 0)
			modifier = modifier + " ";
		AddCode(".property " + modifier + ResolveType(property::type)::ToString() + " " + property::name);
		if (property::getter != null)
			AddCode("\t.get " + GetMethodSignature(property::getter));
		if (property::setter != null)
			AddCode("\t.set " + GetMethodSignature(property::setter));
	}

	private CompileMethod(Method method)
	{
		Core.String modifier = Modifier::ToString(method::modifier);
		if (modifier::Length > 0)
			modifier = modifier + " ";

		AddCode(".method " + modifier + "function " + method::name + ResolvePrototype(method));

		if (method::modifier & Modifier::Internal > 0 || method::modifier & Modifier::Abstract > 0)
		{
			/* Do nothing */
		}
		else if (method::modifier & Modifier::Native > 0)
		{
			AddCode("[" + CallingConvention::ToString(method::callingConvention) + ", \"" + method::libraryName
				+ "\", \"" + method::originalName + "\"]");
		}
		else
		{
			/* Check for improper override */
			if (method::modifier & Modifier::Override > 0)
			{
				/* Check if it actually overrides a method */
				/* HACK: bool */
				int32 ok = 0;
				Class c = method::classObject;
				while (c::baseClass != null)
				{
					c = c::baseClass;
					Vector methods = c::methods::FindAll(method::name);
					/* HACK: bool */
					int32 done = 0;
					for (int32 i = 0; i < methods::Size; i = i + 1)
					{
						Method another = [Method] methods[i];
						if (ResolvePrototype(method)::Equals(ResolvePrototype(another)) > 0)
						{
							if (another::modifier & Modifier::Virtual > 0 || another::modifier & Modifier::Abstract > 0)
							{
								done = 1;
								ok = 1;
								break;
							}
							else if (another::modifier & Modifier::Override == 0)
							{
								done = 1;
								break;
							}
						}
					}
					if (done > 0)
						break;
				}
				if (ok == 0)
					throw new CompilerException("The method \"" + method::name
						+ "\" makred with \"override\" does not override any methods.", method::location);
			}
			else
			{
				/* TODO: Check implicit override and display a warning */
			}

			AddCode("{");
			Tab();
			PushSymbolStack();

			Context context = new Context();
			int32 freereg = 0;
			if (method::modifier & Modifier::Static == 0)
				freereg = freereg + 1;

			for (int32 i = 0; i < method::paramNames::Size; i = i + 1)
			{
				Core.String name = [Core.String] method::paramNames[i];
				if (name::Equals("") == 0)
				{
					Variable var = new Variable();
					var::regid = freereg + i;
					var::type = ResolveType([ParserType] method::paramTypes[i]);
					([Hash] symbolTable::Peek())::Add(name, [Core.Object] var);
				}
			}
			freereg = freereg + method::paramNames::Size;
			context::firstReturnRegister = freereg;
			for (int32 i = 0; i < method::returnNames::Size; i = i + 1)
			{
				Core.String name = [Core.String] method::returnNames[i];
				if (name::Equals("") == 0)
				{
					Variable var = new Variable();
					var::regid = freereg + i;
					var::type = ResolveType([ParserType] method::returnTypes[i]);
					([Hash] symbolTable::Peek())::Add(name, [Core.Object] var);
				}
			}
			freereg = freereg + method::returnNames::Size;

			currentMethod = method;
			currentLabelId = 1;
			int32 closed = CompileStatement(method::body, freereg, context);
			if (closed == 0 || context::generateEpilogue > 0)	
			{
				if (context::generateEpilogue > 0)
					AddStringLabel("_Epilogue");
				/* Unclosed statement block, insert return statement manually */
				if (method::returnNames::Size == 0)
					AddCode("ret");
				else if (method::returnNames::Size == 1)
					AddCode("ret\t$" + context::firstReturnRegister);
				else
					AddCode("ret\t$" + context::firstReturnRegister + ", $"
						+ (context::firstReturnRegister + method::returnTypes::Size));
			}

			PopSymbolStack();
			Untab();
			AddCode("}");
		}
	}

	/* Returns whether the statement block is fully closed (has return statements in all possible control flows) */
	/* Returns 'closed' and 'nextfreereg' */
	private CompileStatement(Node node, int32 freereg, Context context) -> int32, int32
	{
		if (node::op == Token::MultipleNode)
		{
			PushSymbolStack();
			int32 closed = 0, _freereg = freereg;
			MultipleNode mnode = [MultipleNode] node;
			for (int32 i = 0; i < mnode::nodes::Size; i = i + 1)
				closed, _freereg = CompileStatement([Node] mnode::nodes[i], _freereg, context);
			PopSymbolStack();
			return closed, freereg;
		}
		else if (node::op == Token::Definition)
		{
			DefinitionNode dnode = [DefinitionNode] node;
			for (int32 i = 0; i < dnode::names::Size; i = i + 1)
			{
				Variable variable = new Variable();
				variable::regid = freereg;
				variable::type = ResolveType(dnode::type);

				([Hash] symbolTable::Peek())::Add([Core.String] dnode::names[i], [Core.Object] variable);
				Variable var = FindSymbol([Core.String] dnode::names[i]);

				Core.Object vn = dnode::values[i];
				if (vn != null)
				{
					Node vnode = [Node] vn;
					LValue value = new VariableValue(dnode::location, freereg, ResolveType(dnode::type));
					CompileExpression(vnode, freereg, freereg, 0, 0)::ToLValue(this, value, freereg);
				}
				freereg = freereg + 1;
			}
			return 0, freereg;
		}
		else if (node::op == Token::If)
		{
			IfNode inode = [IfNode] node;
			if (inode::falseBody == null)
			{
				/* If - Then */
				int32 falseTarget = GetNextLabelId();
				CompileExpression(inode::condition, freereg, freereg, falseTarget, 0)
					::ToJumpTarget(this, freereg, falseTarget, 0);
				CompileStatement(inode::trueBody, freereg, context);
				AddLabel(falseTarget);
				return 0, freereg;
			}
			else
			{
				/* If - Then - Else */
				int32 falseTarget = GetNextLabelId();
				int32 endTarget = GetNextLabelId();
				CompileExpression(inode::condition, freereg, freereg, falseTarget, 0)
					::ToJumpTarget(this, freereg, falseTarget, 0);
				int32 thenClosed, elseClosed;
				thenClosed = CompileStatement(inode::trueBody, freereg, context);
				if (thenClosed == 0)
					AddCode("jmp\t" + GetLabelName(endTarget));
				AddLabel(falseTarget);
				elseClosed = CompileStatement(inode::falseBody, freereg, context);
				if (thenClosed == 0)
					AddLabel(endTarget);
				return thenClosed & elseClosed, freereg;
			}
		}
		else if (node::op == Token::For)
		{
			PushSymbolStack();
			context::loopLevel = context::loopLevel + 1;
			int32 backupContinueLabelId = context::continueLabelId;
			int32 backupBreakLabelId = context::breakLabelId;
			context::contextType::Push([Core.Object] Core.Int32::ToString(Context::Loop));

			ForNode fnode = [ForNode] node;
			int32 bodyTarget = GetNextLabelId();
			int32 conditionTarget;
			if (fnode::condition != null)
				conditionTarget = GetNextLabelId();
			int32 closed, _freereg = freereg;

			context::continueLabelId = 0;
			context::breakLabelId = 0;
			if (fnode::condition == null && fnode::update == null)
				context::continueLabelId = bodyTarget;

			if (fnode::init != null)
				closed, _freereg = CompileStatement(fnode::init, freereg, context);
			if (fnode::condition != null)
				AddCode("jmp\t" + GetLabelName(conditionTarget));
			AddLabel(bodyTarget);
			CompileStatement(fnode::body, _freereg, context);
			if ((fnode::condition != null || fnode::update != null) && context::continueLabelId > 0)
				AddLabel(context::continueLabelId);
			if (fnode::update != null)
				CompileList(fnode::update, _freereg, -1);
			if (fnode::condition == null)
				AddCode("jmp\t" + GetLabelName(bodyTarget));
			else
			{
				AddLabel(conditionTarget);
				CompileExpression(fnode::condition, _freereg, _freereg, bodyTarget, 1)
					::ToJumpTarget(this, _freereg, bodyTarget, 1);
			}

			if (context::breakLabelId > 0)
				AddLabel(context::breakLabelId);
			context::contextType::Pop();
			context::continueLabelId = backupContinueLabelId;
			context::breakLabelId = backupBreakLabelId;
			context::loopLevel = context::loopLevel - 1;
			PopSymbolStack();
			return 0, freereg;
		}
		else if (node::op == Token::While)
		{
			context::loopLevel = context::loopLevel + 1;
			int32 backupContinueLabelId = context::continueLabelId;
			int32 backupBreakLabelId = context::breakLabelId;
			context::contextType::Push([Core.Object] Core.Int32::ToString(Context::Loop));

			WhileNode wnode = [WhileNode] node;
			int32 bodyTarget = GetNextLabelId();
			int32 conditionTarget = GetNextLabelId();

			context::continueLabelId = conditionTarget;
			context::breakLabelId = 0;
			AddCode("jmp\t" + GetLabelName(conditionTarget));
			AddLabel(bodyTarget);
			CompileStatement(wnode::body, freereg, context);
			AddLabel(conditionTarget);
			CompileExpression(wnode::condition, freereg, freereg, bodyTarget, 1)
				::ToJumpTarget(this, freereg, bodyTarget, 1);

			if (context::breakLabelId > 0)
				AddLabel(context::breakLabelId);
			context::contextType::Pop();
			context::continueLabelId = backupContinueLabelId;
			context::breakLabelId = backupBreakLabelId;
			context::loopLevel = context::loopLevel - 1;
			return 0, freereg;
		}
		else if (node::op == Token::Do)
		{
			context::loopLevel = context::loopLevel + 1;
			int32 backupContinueLabelId = context::continueLabelId;
			int32 backupBreakLabelId = context::breakLabelId;
			context::contextType::Push([Core.Object] Core.Int32::ToString(Context::Loop));

			WhileNode wnode = [WhileNode] node;
			int32 bodyTarget = GetNextLabelId();

			context::continueLabelId = 0;
			context::breakLabelId = 0;
			AddLabel(bodyTarget);
			CompileStatement(wnode::body, freereg, context);
			if (context::continueLabelId > 0)
				AddLabel(context::continueLabelId);
			CompileExpression(wnode::condition, freereg, freereg, bodyTarget, 1)
				::ToJumpTarget(this, freereg, bodyTarget, 1);

			if (context::breakLabelId > 0)
				AddLabel(context::breakLabelId);
			context::contextType::Pop();
			context::continueLabelId = backupContinueLabelId;
			context::breakLabelId = backupBreakLabelId;
			context::loopLevel = context::loopLevel - 1;
			return 0, freereg;
		}
		else if (node::op == Token::Return)
		{
			ReturnNode rnode = [ReturnNode] node;
			if (rnode::values::Size != currentMethod::returnTypes::Size && rnode::values::Size != 0)
				throw new CompilerException("Unmatched number of return values.", node::location);
			if (context::finallyLevel > 0)
				throw new CompilerException("Control cannot go out of the finally block.", node::location);
			if (context::tryCatchLevel > 0)
			{
				/* We are inside a try finally block */
				/* First, save supplied return values into return registers */
				for (int32 i = 0; i < rnode::values::Size; i = i + 1)
				{
					Node vnode = [Node] rnode::values[i];
					/* TODO: Type */
					CompileExpression(vnode, freereg, context::firstReturnRegister + i, 0, 0)
						::ToFreeRegister(this, context::firstReturnRegister + 1);
				}
				/* Second, add leave instruction */
				AddCode("leave\t_Epilogue");
				/* Last, tell CompileMethod() that we need an epilogue */
				context::generateEpilogue = 1;
			}
			else
			{
				/* Normal return */
				if (currentMethod::returnTypes::Size == 0)
					AddCode("ret");
				else if (currentMethod::returnTypes::Size == 1)
				{
					if (rnode::values::Size == 0)
						AddCode("ret\t$" + context::firstReturnRegister);
					else
					{
						RegisterValue value = CompileExpression([Node] rnode::values[0], freereg, freereg, 0, 0)
							::EnsureRegister(this, freereg);
						AddCode("ret\t$" + value::regid);
					}
				}
				else
				{
					if (rnode::values::Size == 0)
						AddCode("ret\t$" + context::firstReturnRegister + ", $"
							+ (context::firstReturnRegister + currentMethod::returnTypes::Size - 1));
					else
					{
						for (int32 i = 0; i < rnode::values::Size; i = i + 1)
						{
							Node vnode = [Node] rnode::values[i];
							/* TODO: Type */
							CompileExpression(vnode, freereg + i, freereg + i, 0, 0)
								::ToFreeRegister(this, freereg + i);
						}
						AddCode("ret\t$" + freereg + ", $" + (freereg + rnode::values::Size - 1));
					}
				}
			}
			return 1, freereg;
		}
		else if (node::op == Token::Continue)
		{
			if (context::loopLevel == 0)
				throw new CompilerException("Not in a loop.", node::location);
			int32 ctx = Core.Int32::Parse([Core.String] context::contextType::Peek());
			if (ctx == Context::Finally)
				throw new CompilerException("Control cannot go out of the finally block.", node::location);

			context::continueLabelId = FixJumpTarget(context::continueLabelId);
			if (ctx == Context::TryCatch)
				AddCode("leave\t" + GetLabelName(context::continueLabelId));
			else
				AddCode("jmp\t" + GetLabelName(context::continueLabelId));
			return 1, freereg;
		}
		else if (node::op == Token::Break)
		{
			if (context::loopLevel == 0)
				throw new CompilerException("Not in a loop.", node::location);
			int32 ctx = Core.Int32::Parse([Core.String] context::contextType::Peek());
			if (ctx == Context::Finally)
				throw new CompilerException("Control cannot go out of the finally block.", node::location);

			context::breakLabelId = FixJumpTarget(context::breakLabelId);
			if (ctx == Context::TryCatch)
				AddCode("leave\t" + GetLabelName(context::breakLabelId));
			else
				AddCode("jmp\t" + GetLabelName(context::breakLabelId));
			return 0, freereg;
		}
		else if (node::op == Token::Try)
		{
			TryNode tnode = [TryNode] node;
			int32 endTarget = currentLabelId;
			currentLabelId = currentLabelId + 1;

			if (tnode::finallyNode != null)
			{
				context::tryCatchLevel = context::tryCatchLevel + 1;
				context::contextType::Push([Core.Object] Core.Int32::ToString(Context::TryCatch));
			}

			AddCode(".try {");
			Tab();
			int32 closed = CompileStatement(tnode::body, freereg, context);
			if (closed == 0)
				if (tnode::finallyNode == null)
					AddCode("jmp\t" + GetLabelName(endTarget));
				else
					AddCode("leave\t" + GetLabelName(endTarget));
			Untab();
			AddCode("}");
			for (int32 i = 0; i < tnode::catchNodes::Size; i = i + 1)
			{
				CatchNode cnode = [CatchNode] tnode::catchNodes[i];
				AddCode(".catch(" + ResolveType(cnode::type)::ToString() + " $" + freereg + ") {");
				PushSymbolStack();
				Variable var = new Variable();
				var::regid = freereg;
				var::type = ResolveType(cnode::type);
				([Hash] symbolTable::Peek())::Add(cnode::name, [Core.Object] var);
				Tab();
				int32 closed = CompileStatement(cnode::body, freereg + 1, context);
				if (closed == 0)
					if (tnode::finallyNode == null)
						AddCode("jmp\t" + GetLabelName(endTarget));
					else
						AddCode("leave\t" + GetLabelName(endTarget));
				Untab();
				AddCode("}");
				PopSymbolStack(); 
			}
			if (tnode::finallyNode != null)
			{
				context::tryCatchLevel = context::tryCatchLevel - 1;
				context::contextType::Pop();
				context::finallyLevel = context::finallyLevel + 1;
				context::contextType::Push([Core.Object] Core.Int32::ToString(Context::Finally));

				AddCode(".finally {");
				Tab();
				CompileStatement(tnode::finallyNode, freereg, context);
				AddCode("endfinally");
				Untab();
				AddCode("}");

				context::contextType::Pop();
				context::finallyLevel = context::finallyLevel - 1;
			}
			AddLabel(endTarget);
			return 0, freereg;
		}
		else if (node::op == Token::Throw)
		{
			ThrowNode tnode = [ThrowNode] node;
			RegisterValue value = ToScalar(CompileList(tnode::exception, freereg, -1))::EnsureRegister(this, freereg);
			AddCode("throw\t$" + value::regid);
			return 1, freereg;
		}
		else
		{
			CompileList(node, freereg, -1);
			return 0, freereg;
		}
	}

	/* Call node is the only 'expression'-like node that can return multiple values (or zero). */
	/* So don't bother mentioning it many times here */
	/* Save last scalar value to 'lastreg' if 'lastreg' != -1 */
	private CompileList(Node node, int32 freereg, int32 lastreg) -> Vector
	{
		return node::CompileList(this, freereg, lastreg);
	}

	private FixJumpTarget(int32 jtarget) -> int32
	{
		if (jtarget == 0)
		{
			currentLabelId = currentLabelId + 1;
			return currentLabelId - 1;
		}
		else
			return jtarget;
	}

	/* Convert types to a unified stack type for doing arithmetic */
	private UnifyTypes(Node node, Value left, Value right, int32 leftreg, int32 rightreg) -> TypedValue, TypedValue
	{
		/* TODO: Immediate value */
		Type type;

		if (left::CanImplicitlyConvertTo(Type::Int8) > 0 && right::CanImplicitlyConvertTo(Type::Int8) > 0)
			type = Type::Int8;
		else if (left::CanImplicitlyConvertTo(Type::UInt8) > 0 && right::CanImplicitlyConvertTo(Type::UInt8) > 0)
			type = Type::UInt8;
		else if (left::CanImplicitlyConvertTo(Type::Int16) > 0 && right::CanImplicitlyConvertTo(Type::Int16) > 0)
			type = Type::Int16;
		else if (left::CanImplicitlyConvertTo(Type::UInt16) > 0 && right::CanImplicitlyConvertTo(Type::UInt16) > 0)
			type = Type::UInt16;
		else if (left::CanImplicitlyConvertTo(Type::Int32) > 0 && right::CanImplicitlyConvertTo(Type::Int32) > 0)
			type = Type::Int32;
		else if (left::CanImplicitlyConvertTo(Type::UInt32) > 0 && right::CanImplicitlyConvertTo(Type::UInt32) > 0)
			type = Type::UInt32;
		else
			throw new CompilerException("Uncompatible types.", node::location);

		TypedValue l = left::ToTyped(this, leftreg, type);
		TypedValue r = right::ToTyped(this, rightreg, type);

		return l, r;
	}

	/* Convert to a typed value from its corresponding raw stack value */
	private FixRawValue(RegisterValue value, int32 targetreg) -> RegisterValue
	{
		/* TODO: Immediate value */
		Type stackType = value::type::StackType;
		if (value::type::Equals(stackType) == 0)
		{
			RegisterValue ret = value::EnsureRegister(this, targetreg);
			AddCode("conv\t" + value::type::ToString() + " $" + targetreg + ", "
				+ stackType::ToString() + " $" + value::regid);
			value::regid = targetreg;
			return value;
		}
		else
			return value;
	}

	/* Return 'value' */
	private CompileExpression(Node node, int32 freereg, int32 targetreg, int32 jtarget, int32 jtrue) -> Value
	{
		return node::CompileExpression(this, freereg, targetreg, jtarget, jtrue);
	}

	private CompileCustomBinaryOperator(Node node, int32 op, TypedValue left, TypedValue right, int32 firstreg) -> Value
	{
		TypedValue l = left::EnsureSingleSlot(this, firstreg);
		TypedValue r = right::EnsureSingleSlot(this, firstreg + 1);

		Core.String methodName = GetOperatorMethodName(op);
		if (methodName == null)
			throw new CompilerException("Unsupported operator.", node::location);

		Vector methods = new Vector();
		if (l::type is ClassType)
			ResolveMethod(([ClassType] l::type)::Class, methodName, methods);
		if (r::type is ClassType)
			ResolveMethod(([ClassType] r::type)::Class, methodName, methods);

		Vector values = new Vector();
		values::Add(l);
		values::Add(r);

		Method method = PrepareCall(node, methods, values, firstreg);
		AddCode("call\t$" + firstreg + ", " + GetMethodSignature(method));
		return new RegisterValue(node::location, firstreg, ResolveType([ParserType] method::returnTypes[0]));
	}

	/* Resolves a type from standarized type string */
	private ResolveParserType(Location location, Core.String type) -> Type
	{
		if (type::Equals("bool") > 0)
			return Type::Bool;
		else if (type::Equals("int8") > 0)
			return Type::Int8;
		else if (type::Equals("uint8") > 0)
			return Type::UInt8;
		else if (type::Equals("int16") > 0)
			return Type::Int16;
		else if (type::Equals("uint16") > 0)
			return Type::UInt16;
		else if (type::Equals("int32") > 0)
			return Type::Int32;
		else if (type::Equals("uint32") > 0)
			return Type::UInt32;
		else if (type::Equals("char") > 0)
			return Type::Char;
		else if (type::Equals("int") > 0)
			return Type::Int;
		else if (type::SubString(type::Length - 2, 2)::Equals("[]") > 0)
			return new ArrayType(ResolveParserType(location, type::SubString(0, type::Length - 2)));
		else if (type::SubString(type::Length - 1, 1)::Equals("*") > 0)
			return new PointerType(ResolveParserType(location, type::SubString(0, type::Length - 1)));
		else
		{
			Core.Object c;
			int32 found;
			found, c = classes::Contains(type);
			if (found == 0)
				throw new CompilerException("Unknown type \"" + type + "\".", location);
			return new ClassType([Class] c);
		}
	}

	private ResolveType(ParserType type) -> Type
	{
		if (type::type == null)
			type::type = ResolveParserType(type::location, type::typestring);
		return type::type;
	}

	private ResolvePrototype(Method method) -> Core.String
	{
		if (method::prototype == null)
		{
			/* Concatenate prototype string */
			Core.String prototype = "(";
			for (int32 i = 0; i < method::paramTypes::Size; i = i + 1)
			{
				if (i == 0)
					prototype = prototype + ResolveType([ParserType] method::paramTypes[i])::ToString();
				else
					prototype = prototype + ", " + ResolveType([ParserType] method::paramTypes[i])::ToString();
			}
			prototype = prototype + ")";
			if (method::returnTypes::Size > 0)
			{
				prototype = prototype + " -> ";
				for (int32 i = 0; i < method::returnTypes::Size; i = i + 1)
				{
					if (i == 0)
						prototype = prototype + ResolveType([ParserType] method::returnTypes[i])::ToString();
					else
						prototype = prototype + ", " + ResolveType([ParserType] method::returnTypes[i])::ToString();
				}
			}
			method::prototype = prototype;
		}
		return method::prototype;
	}

	/* Resolves a field, returns null if not found */
	private ResolveField(Class startClass, Core.String name) -> Field
	{
		Class c = startClass;
		while (c != null)
		{
			Core.Object field;
			int32 found;
			if ((found, field = c::fields::Contains(name)) > 0)
				return [Field] field;
			c = c::baseClass;
		}
		return null;
	}

	/* Resolves a property, returns null if not found */
	private ResolveProperty(Class startClass, Core.String name) -> Property
	{
		Class c = startClass;
		while (c != null)
		{
			Core.Object property;
			int32 found;
			if ((found, property = c::properties::Contains(name)) > 0
				&& ([Property] property)::modifier & Modifier::Override == 0)
					return [Property] property;
			c = c::baseClass;
		}
		return null;
	}

	/* Resolves a method by name, append possible candidates to `methods` vector */
	private ResolveMethod(Class startClass, Core.String name, Vector methods) -> Vector
	{
		if (methods == null)
			methods = new Vector();
		Class c = startClass;
		while (c != null)
		{
			ResolveMethodInClass(c, name, methods);
			c = c::baseClass;
		}
		return methods;
	}

	/* Resolves a method in a single class */
	private ResolveMethodInClass(Class classObject, Core.String name, Vector methods) -> Vector
	{
		if (methods == null)
			methods = new Vector();
		Vector current = classObject::methods::FindAll(name);
		for (int32 i = 0; i < current::Size; i = i + 1)
		{
			Method method = [Method] current[i];
			if (method::modifier & Modifier::Override == 0) /* Do not include overridden methods */
			{
				/* HACK: bool */
				int32 ok = 1;
				/* Make sure this method is not overridden by a subclass method */
				for (int32 j = 0; j < methods::Size; j = j + 1)
				{
					Method another = [Method] methods[j];
					if (ResolvePrototype(method)::Equals(ResolvePrototype(another)) > 0)
					{
						ok = 0;
						break;
					}
				}
				if (ok > 0)
					methods::Add([Core.Object] method);
			}
		}
		return methods;
	}

	/* Choose best method in `methods`,
	   Ensures `values` are converted to proper types and placed sequentially from `firstreg`
	   Returns best method */
	private PrepareCall(Node node, Vector methods, Vector values, int32 firstreg) -> Method
	{
		Vector candidates = new Vector();
		/* Check valid candidates */
		for (int32 i = 0; i < methods::Size; i = i + 1)
		{
			Method method = [Method] methods[i];
			if (method::paramTypes::Size == values::Size)
			{
				/* HACK: bool */
				int32 ok = 1;
				for (int32 j = 0; j < method::paramTypes::Size; j = j + 1)
					if (([Value] values[j])::CanImplicitlyConvertTo(ResolveType([ParserType] method::paramTypes[j])) == 0)
					{
						ok = 0;
						break;
					}
				if (ok > 0)
					candidates::Add([Core.Object] method);
			}
		}
		Method method = ChooseBestMethod(node, candidates, values);
		/* Prepare values */
		for (int32 i = 0; i < values::Size; i = i + 1)
			([Value] values[i])::ToTypedRegister(
				this, firstreg + i, firstreg + i, ResolveType([ParserType] method::paramTypes[i])
			);
		return method;
	}

	/* S = Given type, T1 = Method 1 type, T2 = Method 2 type
	 * `->` means implicitly convertible
	 * Rules:
	 * 1. If T1 = T2, neither is better.
	 * 2. If S = T1, T1 is better.
	 *    If S = T2, T2 is better.
	 * 3. If T1 -> T2 and not T2 -> T1, T1 is beter.
	 *    If T2 -> T1 and not T1 -> T2, T2 is better.
	 * 4. Otherwise, neither is better.
	 */
	private ChooseBestMethod(Node node, Vector methods, Vector values) -> Method
	{
		if (methods::Size == 0)
			throw new CompilerException("No method prototype match type of given parameters.", node::location);
		for (int32 i = 0; i < methods::Size; i = i + 1)
		{
			Method current = [Method] methods[i];
			/* HACK: bool */
			int32 ok = 1;
			for (int32 j = 0; j < methods::Size; j = j + 1)
				if (i != j)
				{
					Method another = [Method] methods[j];
					/* HACK: bool */
					int32 better = 0;
					for (int32 k = 0; k < values::Size; k = k + 1)
					{
						Type S = Type::Unit;
						if (values[k] is TypedValue)
							S = ([TypedValue] values[k])::type;
						Type T1 = ResolveType([ParserType] current::paramTypes[k]);
						Type T2 = ResolveType([ParserType] another::paramTypes[k]);
						if (T1::Equals(T2) > 0)
							continue;
						if (S::Equals(T1) > 0)
						{
							better = 1;
							continue;
						}
						if (S::Equals(T2) > 0)
						{
							better = 0;
							break;
						}
						/* HACK: bool */
						int32 c1 = T1::CanImplicitlyConvertTo(T2), c2 = T2::CanImplicitlyConvertTo(T1);
						if (c1 > 0 && c2 == 0)
							better = 1;
						else if (c1 == 0 && c2 > 0)
						{
							better = 0;
							break;
						}
					}
					/* Best method must be better than any other method */
					if (better == 0)
					{
						ok = 0;
						break;
					}
				}
			if (ok > 0)
				return current;
		}
		throw new CompilerException("Ambiguous function call.", node::location);
	}
}
