class CompilerException
{
	public Core.String message;
	public Location location;

	public function .ctor(Core.String message, Location location)
	{
		this::message = message;
		this::location = location;
	}

	public function ToString() -> Core.String
	{
		return location::ToString() + ": " + message;
	}
}

class Variable
{
	public int32 regid;
	public Core.String type;
}

class Value
{
	public static int32 Register, IntegerImmediate, Immediate, Field, Method, ArrayElement;
	public static int32 Deref, LValue, Type, JumpTarget;

	public static function InitValue()
	{
		Value::Register, Value::IntegerImmediate, Value::Immediate, Value::Field, Value::Method = 1, 2, 4, 8, 16;
		Value::ArrayElement, Value::Deref, Value::LValue, Value::Type, Value::JumpTarget = 32, 64, 128, 256, 512;
	}

	public int32 kind;
	public int32 regid, regid2;
	public int32 labelid;
	public Core.String intvalue;
	public Class classObject;
	public Vector methods;
	public Field field;
	public Core.String type;
}

class Context
{
	public static int32 Loop, TryCatch, Finally;

	public int32 loopLevel, tryCatchLevel, finallyLevel;
	public int32 continueLabelId;
	public int32 breakLabelId;
	public int32 firstReturnRegister;
	public Stack contextType;
	/* HACK: bool */
	public int32 generateEpilogue;

	public function .ctor()
	{
		contextType = new Stack();
	}

	public static function InitContext()
	{
		Context::Loop, Context::TryCatch, Context::Finally = 1, 2, 3;
	}
}

class Compiler
{
	private Hash classes;

	public Vector code;
	private int32 tab;
	private Stack symbolTable; /* Stack of symbol hashes */
	private Class currentClass;
	private Method currentMethod;
	private int32 currentLabelId;

	public function .ctor(Hash classes)
	{
		this::classes = classes;
		code = new Vector();
		symbolTable = new Stack();
	}

	private function GetLabelName(int32 labelId) -> Core.String
	{
		return "_L" + Core.Int32::ToString(labelId);
	}

	private function AddCode(Core.String line)
	{
		Core.String tabs = "";
		for (int32 i = 0; i < tab; i = i + 1)
			tabs = tabs + "\t";
		code::Add([Core.Object] (tabs + line));
	}

	private function AddLabel(int32 labelId)
	{
		code::Add([Core.Object] (GetLabelName(labelId) + ":"));
	}

	private function AddStringLabel(Core.String label)
	{
		code::Add([Core.Object] (label + ":"));
	}

	private function Tab()
	{
		tab = tab + 1;
	}

	private function Untab()
	{
		tab = tab - 1;
	}

	private function PushSymbolStack()
	{
		symbolTable::Push([Core.Object] new Hash());
	}

	private function PopSymbolStack()
	{
		symbolTable::Pop();
	}

	private function FindSymbol(Core.String name) -> Variable, int32
	{
		for (int32 i = symbolTable::.getSize() - 1; i >= 0; i = i - 1)
		{
			int32 found;
			Core.Object ret;
			if ((found, ret = ([Hash] symbolTable::data[i])::Contains(name)) > 0)
				return [Variable] ret, 1;
		}
		return null, 0;
	}

	public static function GetOperatorMethodName(int32 op) -> Core.String
	{
		if (op == Token::Add)
			return ".opAdd";
		else if (op == Token::Sub)
			return ".opSub";
		else if (op == Token::Mul)
			return ".opMul";
		else if (op == Token::Div)
			return ".opDiv";
		else if (op == Token::Rem)
			return ".opRem";
		else if (op == Token::LT)
			return ".opLT";
		else if (op == Token::LE)
			return ".opLE";
		else if (op == Token::GT)
			return ".opGT";
		else if (op == Token::GE)
			return ".opGE";
		else if (op == Token::EQ)
			return ".opEQ";
		else if (op == Token::NEQ)
			return ".opNEQ";
		else if (op == Token::Array)
			return ".opArrayElement";
		else
			return null;
	}

	private function IsPrimitiveType(Core.String type) -> int32
	{
		return type::Equals("uint8") > 0 || type::Equals("int8") > 0
			|| type::Equals("uint16") > 0 || type::Equals("int16") > 0
			|| type::Equals("uint32") > 0 || type::Equals("int32") > 0
			|| type::Equals("uint64") > 0 || type::Equals("int64") > 0
			|| type::Equals("char") > 0 || type::Equals("int") > 0;
	}

	/* Get instruction suffix for given type */
	private function GetTypeSuffix(Core.String type) -> Core.String
	{
		if (type::Equals("bool") > 0 || type::Equals("int8") > 0)
			return "b";
		else if (type::Equals("uint8") > 0)
			return "ub";
		else if (type::Equals("int16") > 0)
			return "w";
		else if (type::Equals("uint16") > 0 || type::Equals("char") > 0) /* TODO: char */
			return "uw";
		else if (type::Equals("int32") > 0)
			return "i";
		else if (type::Equals("uint32") > 0)
			return "u";
		else if (type::Equals("int") > 0)
			return "a";
		else if (type::SubString(type::.getLength() - 2, 2)::Equals("[]") > 0)
			return "a";
		else if (classes::Contains(type) > 0)
			return "a";
		else
			throw new Core.InvalidOperationException();
	}

	/* Get register stack type for given type */
	private function GetStackType(Core.String type) -> Core.String
	{
		if (type::Equals("bool") > 0 || type::Equals("int8") > 0 || type::Equals("int16") > 0 || type::Equals("int32") > 0
			|| type::Equals("char") > 0)
			return "int32";
		else if (type::Equals("uint8") > 0 || type::Equals("uint16") > 0 || type::Equals("uint32") > 0)
			return "uint32";
		else if (type::Equals("int") > 0)
			return "int";
		else
			return "int";
	}

	/* Test if `srctype` can be implicitly converted to `dsttype` */
	/* HACK: bool */
	private function IsTypeConvertible(Core.String srctype, Core.String dsttype) -> int32
	{
		if (srctype::Equals("bool") > 0)
			if (dsttype::Equals("bool") > 0)
				return 1;
			else
				return 0;
		else if (srctype::Equals("int8") > 0)
			if (dsttype::Equals("int8") > 0 || dsttype::Equals("int16") > 0 || dsttype::Equals("int32") > 0)
				return 1;
			else
				return 0;
		else if (srctype::Equals("uint8") > 0)
			if (dsttype::Equals("uint8") > 0 || dsttype::Equals("int16") > 0 || dsttype::Equals("uint16") > 0
				|| dsttype::Equals("int32") > 0 || dsttype::Equals("uint32") > 0)
				return 1;
			else
				return 0;
		else if (srctype::Equals("int16") > 0)
			if (dsttype::Equals("int16") > 0 || dsttype::Equals("int32") > 0)
				return 1;
			else
				return 0;
		else if (srctype::Equals("uint16") > 0)
			if (dsttype::Equals("uint16") > 0 || dsttype::Equals("int32") > 0 || dsttype::Equals("uint32") > 0)
				return 1;
			else
				return 0;
		else if (srctype::Equals("int32") > 0)
			if (dsttype::Equals("int32") > 0)
				return 1;
			else
				return 0;
		else if (srctype::Equals("uint32") > 0)
			if (dsttype::Equals("uint32") > 0)
				return 1;
			else
				return 0;
		else if (srctype::Equals("int") > 0 && dsttype::Equals("int") > 0)
			return 1;
		else if (srctype::Equals(dsttype) > 0) /* TODO: This is for array dsttype */
			return 1;
		else if (IsPrimitiveType(srctype) == 0 && IsPrimitiveType(dsttype) == 0)
		{
			/* TODO: This should be a function */
			Class c = [Class] classes[srctype];
			if (c::name::Equals(dsttype) > 0)
				return 1;
			while (c::baseName::Equals("") == 0)
			{
				c = [Class] classes[c::baseName];
				if (c::name::Equals(dsttype) > 0)
					return 1;
			}
			return 0;
		}
		else
			return 0;
	}

	/* Test if value can be implicitly converted to type */
	/* HACK: bool */
	private function IsConvertible(Value value, Core.String type) -> int32
	{
		if (value::kind & Value::IntegerImmediate > 0)
		{
			/* TODO */
			if (type::Equals("int8") > 0 || type::Equals("uint8") > 0 || type::Equals("int16") > 0
				|| type::Equals("uint16") > 0 || type::Equals("int32") > 0 || type::Equals("uint32") > 0)
				return 1;
			else
				return 0;
		}
		/* Null */
		else if (value::type::Equals("int") > 0 && value::kind & Value::Immediate > 0 && IsPrimitiveType(type) == 0)
			return 1;
		else
			return IsTypeConvertible(value::type, type);
	}

	/* Move register $src to $dst of type 'type' */
	private function MoveRegisterToRegister(int32 src, int32 dst, Core.String type)
	{
		if (dst != src)
			AddCode("ld" + GetTypeSuffix(type) + "\t$" + Core.Int32::ToString(dst) + ", $" + Core.Int32::ToString(src));
	}

	/* Move value to register */
	private function MoveValueToRegister(Value value, int32 regid) -> Value
	{
		Value ret = new Value();
		ret::kind = Value::Register;
		ret::regid = regid;
		ret::type = value::type;

		if (value::kind & Value::Register > 0)
			MoveRegisterToRegister(value::regid, regid, GetStackType(value::type));
		else if (value::kind & Value::IntegerImmediate > 0)
		{
			/* TODO */
			AddCode("ldi\t$" + Core.Int32::ToString(regid) + ", " + value::intvalue);
			ret::type = "int32";
		}
		else if (value::kind & Value::Immediate > 0 && value::type::Equals("int") > 0) /* HACK: Only null supported now */
			AddCode("ldnull\t$" + Core.Int32::ToString(regid));
		else if (value::kind & Value::Deref > 0)
			AddCode("ldiuw\t$" + Core.Int32::ToString(regid) + ", ($" + Core.Int32::ToString(value::regid) + ")");
		else if (value::kind & Value::JumpTarget > 0)
		{
			/* Default: jtrue == 0 */
			AddCode("ldi\t$" + Core.Int32::ToString(regid) + ", 1");
			AddCode("jmp\t" + GetLabelName(currentLabelId));
			AddLabel(value::labelid);
			AddCode("ldi\t$" + Core.Int32::ToString(regid) + ", 0");
			AddLabel(currentLabelId);
			currentLabelId = currentLabelId + 1;
		}
		else if (value::kind & Value::Field > 0)
		{
			Field field = value::field;
			if (field::modifier & Modifier::Static > 0)
				AddCode("lds" + GetTypeSuffix(field::type) + "\t$" + Core.Int32::ToString(regid) + ", "
					+ field::classObject::name + "::" + field::name);
			else
				AddCode("ldf" + GetTypeSuffix(field::type) + "\t$" + Core.Int32::ToString(regid) + ", $"
					+ Core.Int32::ToString(value::regid) + ", " + field::classObject::name + "::" + field::name);
		}
		else if (value::kind & Value::ArrayElement > 0)
			AddCode("lde" + GetTypeSuffix(value::type) + "\t$" + Core.Int32::ToString(regid) + ", $"
				+ Core.Int32::ToString(value::regid) + "($" + Core.Int32::ToString(value::regid2) + ")");
		else
			throw new Core.InvalidOperationException();
		return ret;
	}

	private function EnsureRegister(Value value, int32 regid) -> Value
	{
		if (value::kind & Value::Register > 0)
			return value;
		else
			return MoveValueToRegister(value, regid);
	}

	/* Ensure a value occupies a single register slot at most */
	private function EnsureSingleSlotValue(Value value, int32 regid) -> Value
	{
		if (value::kind & Value::Immediate > 0)
			return value;
		else
			return EnsureRegister(value, regid);
	}

	/* Ensure value is of given type, convert it otherwise
	   Caller ensures that value is convertible to type */
	private function EnsureTypedValue(Node node, Value value, int32 freereg, Core.String type) -> Value
	{
		if (value::kind & Value::IntegerImmediate > 0)
		{
			/* TODO */
			return value;
		}

		Core.String stacktype = GetStackType(value::type);
		if (stacktype::Equals(type) > 0 || value::type::Equals(type) > 0)
			return value;
		else if (IsPrimitiveType(value::type) > 0 && IsPrimitiveType(type) > 0)
		{
			/* TODO: Maybe we could cut off some unnecessary convertions */
			Value ret = EnsureRegister(value, freereg);
			AddCode("conv\t" + type + " $" + Core.Int32::ToString(freereg) + ", "
				+ stacktype + " $" + Core.Int32::ToString(ret::regid));
			ret::type = type;
			return ret;
		}
		else if (value::kind & Value::Immediate > 0 && value::type::Equals("int") > 0 /* null */
			&& IsPrimitiveType(type) == 0)
		{
			AddCode("ldnull\t$" + Core.Int32::ToString(freereg));
			Value ret = new Value();
			ret::kind = Value::Register;
			ret::regid = freereg;
			ret::type = type;
			return ret;
		}
		else if (IsPrimitiveType(value::type) == 0 && IsPrimitiveType(type) == 0)
		{
			/* Object cast */
			/* TODO */
			if (IsConvertible(value, type) > 0)
			{
				value::type = type;
				return value;
			}
			else
			{
				Value ret = EnsureRegister(value, freereg);
				AddCode("cast\t$" + Core.Int32::ToString(freereg) + ", $" + Core.Int32::ToString(value::regid) + ", " + type);
				ret::regid = freereg;
				ret::type = type;
				return ret;
			}
		}
		else
		{
			throw new CompilerException(
				"Cannot convert \"" + value::type + "\" to \"" + type + "\"",
				node::location
			);
		}
	}

	/* Convert value to a given type and move in to given register, 
	 * throws an exception if the conversion cannot be done
	 */
	private function MoveValueToTypedRegister(Node node, Value value, int32 regid, Core.String type) -> Value
	{
		return MoveValueToRegister(EnsureTypedValue(node, value, regid, type), regid);
	}

	private function MoveValueToLValue(Node node, Value value, Value lvalue, int32 freereg)
	{
		if (lvalue::kind & Value::Register > 0)
		{
			MoveValueToTypedRegister(node, value, lvalue::regid, lvalue::type);
			return;
		}

		if (IsConvertible(value, lvalue::type) == 0)
			throw new CompilerException(
				"Cannot implicitly convert \"" + value::type + "\" to \"" + lvalue::type + "\"",
				node::location
			);

		/* TODO */
		value = EnsureRegister(EnsureTypedValue(node, value, freereg, lvalue::type), freereg);
		
		if (lvalue::kind & Value::Deref > 0)
		{
			/* TODO: pointer types */
			/* TODO: throw when type mismatch */
			AddCode("ldiuw\t($" + Core.Int32::ToString(lvalue::regid) + "), $" + Core.Int32::ToString(value::regid));
		}
		else if (lvalue::kind & Value::Field > 0)
		{
			/* TODO: throw when type mismatch */
			Field field = lvalue::field;
			if (field::modifier & Modifier::Static > 0)
				AddCode("lds" + GetTypeSuffix(field::type) + "\t" + field::classObject::name + "::" + field::name
					+ ", $" + Core.Int32::ToString(value::regid));
			else
				AddCode("ldf" + GetTypeSuffix(field::type) + "\t$" + Core.Int32::ToString(lvalue::regid) + ", "
					+ field::classObject::name + "::" + field::name + ", $" + Core.Int32::ToString(value::regid));
		}
		else if (lvalue::kind & Value::ArrayElement > 0)
		{
			/* TODO: throw when type mismatch */
			AddCode("lde" + GetTypeSuffix(lvalue::type) + "\t$" + Core.Int32::ToString(lvalue::regid)
				+ "($" + Core.Int32::ToString(lvalue::regid2) + "), $" + Core.Int32::ToString(value::regid));
		}
		else /* TODO: Can this happen? */
			throw new Core.InvalidOperationException();
	}

	private function GetNextFreeRegister(Value value, int32 freereg) -> int32
	{
		if (value::kind & Value::ArrayElement > 0 && (value::regid == freereg || value::regid2 == freereg))
		{
			if (value::regid == freereg + 1 || value::regid2 == freereg + 1)
				return freereg + 2;
			else
				return freereg + 1;
		}
		else if ((value::kind & Value::Register > 0 || value::kind & Value::Deref > 0) && (value::regid == freereg))
			return freereg + 1;
		else if (value::kind & Value::Field > 0 && value::field::modifier & Modifier::Static == 0
			&& value::regid == freereg)
			return freereg + 1;
		else
			return freereg;
	}
	
	private function ToScalar(Vector values) -> Value
	{
		if (values::.getSize() == 0)
			throw new Core.Exception(); /* TODO */
		return [Value] values[0];
	}

	private function Scalar(Value value) -> Vector
	{
		Vector ret = new Vector();
		ret::Add([Core.Object] value);
		return ret;
	}

	public function Compile()
	{
		tab = 0;
		Vector classes = this::classes::values;
		for (int32 i = 0; i < classes::.getSize(); i = i + 1)
		{
			currentClass = [Class] classes[i];
			if (currentClass::baseName::Equals("") > 0)
				AddCode(".class " + currentClass::name);
			else
				AddCode(".class " + currentClass::name + ": " + currentClass::baseName);
			AddCode("{");
			Tab();

			Vector fields = currentClass::fields::values;
			for (int32 j = 0; j < fields::.getSize(); j = j + 1)
				CompileField([Field] fields[j]);

			Vector methods = currentClass::methods::values;
			for (int32 j = 0; j < methods::.getSize(); j = j + 1)
				CompileMethod([Method] methods[j]);

			Untab();
			AddCode("}");
		}
	}

	private function CompileField(Field field)
	{
		Core.String modifier = Modifier::ToString(field::modifier);
		if (modifier::.getLength() > 0)
			modifier = modifier + " ";
		AddCode(".field " + modifier + field::type + " " + field::name);
	}

	private function CompileMethod(Method method)
	{
		Core.String modifier = Modifier::ToString(method::modifier);
		if (modifier::.getLength() > 0)
			modifier = modifier + " ";
		AddCode(".method " + modifier + "function " + method::name + method::type);
		if (method::modifier & Modifier::Internal > 0 || method::modifier & Modifier::Abstract > 0)
		{
			/* Do nothing */
		}
		else if (method::modifier & Modifier::Native > 0)
		{
			AddCode("[" + CallingConvention::ToString(method::callingConvention) + ", \"" + method::libraryName
				+ "\", \"" + method::originalName + "\"]");
		}
		else
		{
			/* Check for improper override */
			if (method::modifier & Modifier::Override > 0)
			{
				/* Check if it actually overrides a method */
				/* HACK: bool */
				int32 ok = 0;
				Class c = method::classObject;
				while (c::baseName::Equals("") == 0)
				{
					c = [Class] classes[c::baseName];
					Vector methods = c::methods::FindAll(method::name);
					/* HACK: bool */
					int32 done = 0;
					for (int32 i = 0; i < methods::.getSize(); i = i + 1)
					{
						Method another = [Method] methods[i];
						if (another::type::Equals(method::type) > 0)
						{
							if (another::modifier & Modifier::Virtual > 0 || another::modifier & Modifier::Abstract > 0)
							{
								done = 1;
								ok = 1;
								break;
							}
							else
							{
								done = 1;
								break;
							}
						}
					}
					if (done > 0)
						break;
				}
				if (ok == 0)
					throw new CompilerException("The method \"" + method::name
						+ "\" makred with \"override\" does not override any methods.", method::location);
			}
			else
			{
				/* TODO: Check implicit override and display a warning */
			}

			AddCode("{");
			Tab();
			PushSymbolStack();

			Context context = new Context();
			int32 freereg = 0;
			if (method::modifier & Modifier::Static == 0)
				freereg = freereg + 1;

			for (int32 i = 0; i < method::paramNames::.getSize(); i = i + 1)
			{
				Core.String name = [Core.String] method::paramNames[i];
				if (name::Equals("") == 0)
				{
					Variable var = new Variable();
					var::regid = freereg + i;
					var::type = [Core.String] method::paramTypes[i];
					([Hash] symbolTable::Peek())::Add(name, [Core.Object] var);
				}
			}
			freereg = freereg + method::paramNames::.getSize();
			context::firstReturnRegister = freereg;
			for (int32 i = 0; i < method::returnNames::.getSize(); i = i + 1)
			{
				Core.String name = [Core.String] method::returnNames[i];
				if (name::Equals("") == 0)
				{
					Variable var = new Variable();
					var::regid = freereg + i;
					var::type = [Core.String] method::returnTypes[i];
					([Hash] symbolTable::Peek())::Add(name, [Core.Object] var);
				}
			}
			freereg = freereg + method::returnNames::.getSize();

			currentMethod = method;
			currentLabelId = 1;
			int32 closed = CompileStatement(method::body, freereg, context);
			if (closed == 0 || context::generateEpilogue > 0)	
			{
				if (context::generateEpilogue > 0)
					AddStringLabel("_Epilogue");
				/* Unclosed statement block, insert return statement manually */
				if (method::returnNames::.getSize() == 0)
					AddCode("ret");
				else if (method::returnNames::.getSize() == 1)
					AddCode("ret\t$" + Core.Int32::ToString(context::firstReturnRegister));
				else
					AddCode("ret\t$" + Core.Int32::ToString(context::firstReturnRegister) + ", $"
						+ Core.Int32::ToString(context::firstReturnRegister + method::returnTypes::.getSize()));
			}

			PopSymbolStack();
			Untab();
			AddCode("}");
		}
	}

	/* Returns whether the statement block is fully closed (has return statements in all possible control flows) */
	/* Returns 'closed' and 'nextfreereg' */
	private function CompileStatement(Node node, int32 freereg, Context context) -> int32, int32
	{
		if (node::op == Token::MultipleNode)
		{
			PushSymbolStack();
			int32 closed = 0, _freereg = freereg;
			MultipleNode mnode = [MultipleNode] node;
			for (int32 i = 0; i < mnode::nodes::.getSize(); i = i + 1)
				closed, _freereg = CompileStatement([Node] mnode::nodes[i], _freereg, context);
			PopSymbolStack();
			return closed, freereg;
		}
		else if (node::op == Token::Definition)
		{
			DefinitionNode dnode = [DefinitionNode] node;
			for (int32 i = 0; i < dnode::names::.getSize(); i = i + 1)
			{
				Variable variable = new Variable();
				variable::regid = freereg;
				variable::type = dnode::type;

				([Hash] symbolTable::Peek())::Add([Core.String] dnode::names[i], [Core.Object] variable);
				Variable var = FindSymbol([Core.String] dnode::names[i]);

				Node vnode = [Node] dnode::values[i];
				if (vnode::op != Token::None)
				{
					Value value = new Value();
					value::kind = Value::Register | Value::LValue;
					value::regid = freereg;
					value::type = dnode::type;
					MoveValueToLValue(node, CompileExpression(vnode, freereg, freereg, 0, 0), value, freereg);
				}
				freereg = freereg + 1;
			}
			return 0, freereg;
		}
		else if (node::op == Token::If)
		{
			IfNode inode = [IfNode] node;
			if (inode::falseBody::op == Token::None)
			{
				/* If - Then */
				int32 falseTarget = currentLabelId;
				currentLabelId = currentLabelId + 1;
				Value value = CompileExpression(inode::condition, freereg, freereg, falseTarget, 0);
				if (value::kind & Value::JumpTarget == 0)
					throw new CompilerException("Jump target expected.", node::location); /* TODO */
				CompileStatement(inode::trueBody, freereg, context);
				AddLabel(falseTarget);
				return 0, freereg;
			}
			else
			{
				/* If - Then - Else */
				int32 falseTarget = currentLabelId;
				currentLabelId = currentLabelId + 1;
				int32 endTarget = currentLabelId;
				currentLabelId = currentLabelId + 1;
				Value value = CompileExpression(inode::condition, freereg, freereg, falseTarget, 0);
				if (value::kind & Value::JumpTarget == 0)
					throw new CompilerException("Jump target expected.", node::location); /* TODO */
				int32 thenClosed, elseClosed;
				thenClosed = CompileStatement(inode::trueBody, freereg, context);
				if (thenClosed == 0)
					AddCode("jmp\t" + GetLabelName(endTarget));
				AddLabel(falseTarget);
				elseClosed = CompileStatement(inode::falseBody, freereg, context);
				if (thenClosed == 0)
					AddLabel(endTarget);
				return thenClosed & elseClosed, freereg;
			}
		}
		else if (node::op == Token::For)
		{
			PushSymbolStack();
			context::loopLevel = context::loopLevel + 1;
			int32 backupContinueLabelId = context::continueLabelId;
			int32 backupBreakLabelId = context::breakLabelId;
			context::contextType::Push([Core.Object] Core.Int32::ToString(Context::Loop));

			ForNode fnode = [ForNode] node;
			int32 bodyTarget = currentLabelId;
			currentLabelId = currentLabelId + 1;
			int32 conditionTarget = currentLabelId;
			currentLabelId = currentLabelId + 1;
			int32 closed, _freereg;

			context::continueLabelId = 0;
			context::breakLabelId = 0;
			closed, _freereg = CompileStatement(fnode::init, freereg, context);
			AddCode("jmp\t" + GetLabelName(conditionTarget));
			AddLabel(bodyTarget);
			CompileStatement(fnode::body, _freereg, context);
			if (context::continueLabelId > 0)
				AddLabel(context::continueLabelId);
			CompileList(fnode::update, _freereg, -1);
			AddLabel(conditionTarget);
			Value value = CompileExpression(fnode::condition, _freereg, _freereg, bodyTarget, 1);
			if (value::kind & Value::JumpTarget == 0)
				throw new CompilerException("Jump target expected.", node::location); /* TODO */

			if (context::breakLabelId > 0)
				AddLabel(context::breakLabelId);
			context::contextType::Pop();
			context::continueLabelId = backupContinueLabelId;
			context::breakLabelId = backupBreakLabelId;
			context::loopLevel = context::loopLevel - 1;
			PopSymbolStack();
			return 0, freereg;
		}
		else if (node::op == Token::While)
		{
			context::loopLevel = context::loopLevel + 1;
			int32 backupContinueLabelId = context::continueLabelId;
			int32 backupBreakLabelId = context::breakLabelId;
			context::contextType::Push([Core.Object] Core.Int32::ToString(Context::Loop));

			WhileNode wnode = [WhileNode] node;
			int32 bodyTarget = currentLabelId;
			currentLabelId = currentLabelId + 1;
			int32 conditionTarget = currentLabelId;
			currentLabelId = currentLabelId + 1;

			context::continueLabelId = conditionTarget;
			context::breakLabelId = 0;
			AddCode("jmp\t" + GetLabelName(conditionTarget));
			AddLabel(bodyTarget);
			CompileStatement(wnode::body, freereg, context);
			AddLabel(conditionTarget);
			Value value = CompileExpression(wnode::condition, freereg, freereg, bodyTarget, 1);
			if (value::kind & Value::JumpTarget == 0)
				throw new CompilerException("Jump target expected.", node::location); /* TODO */

			if (context::breakLabelId > 0)
				AddLabel(context::breakLabelId);
			context::contextType::Pop();
			context::continueLabelId = backupContinueLabelId;
			context::breakLabelId = backupBreakLabelId;
			context::loopLevel = context::loopLevel - 1;
			return 0, freereg;
		}
		else if (node::op == Token::Do)
		{
			context::loopLevel = context::loopLevel + 1;
			int32 backupContinueLabelId = context::continueLabelId;
			int32 backupBreakLabelId = context::breakLabelId;
			context::contextType::Push([Core.Object] Core.Int32::ToString(Context::Loop));

			WhileNode wnode = [WhileNode] node;
			int32 bodyTarget = currentLabelId;
			currentLabelId = currentLabelId + 1;

			context::continueLabelId = 0;
			context::breakLabelId = 0;
			AddLabel(bodyTarget);
			CompileStatement(wnode::body, freereg, context);
			if (context::continueLabelId > 0)
				AddLabel(context::continueLabelId);
			Value value = CompileExpression(wnode::condition, freereg, freereg, bodyTarget, 1);
			if (value::kind & Value::JumpTarget == 0)
				throw new CompilerException("Jump target expected.", node::location); /* TODO */

			if (context::breakLabelId > 0)
				AddLabel(context::breakLabelId);
			context::contextType::Pop();
			context::continueLabelId = backupContinueLabelId;
			context::breakLabelId = backupBreakLabelId;
			context::loopLevel = context::loopLevel - 1;
			return 0, freereg;
		}
		else if (node::op == Token::Return)
		{
			ReturnNode rnode = [ReturnNode] node;
			if (rnode::values::.getSize() != currentMethod::returnTypes::.getSize() && rnode::values::.getSize() != 0)
				throw new CompilerException("Unmatched number of return values.", node::location);
			if (context::finallyLevel > 0)
				throw new CompilerException("Control cannot go out of the finally block.", node::location);
			if (context::tryCatchLevel > 0)
			{
				/* We are inside a try finally block */
				/* First, save supplied return values into return registers */
				for (int32 i = 0; i < rnode::values::.getSize(); i = i + 1)
					/* TODO: Type */
					MoveValueToRegister(
						CompileExpression([Node] rnode::values[i], freereg, context::firstReturnRegister + i, 0, 0),
						context::firstReturnRegister + i
					);
				/* Second, add leave instruction */
				AddCode("leave\t_Epilogue");
				/* Last, tell CompileMethod() that we need an epilogue */
				context::generateEpilogue = 1;
			}
			else
			{
				/* Normal return */
				if (currentMethod::returnTypes::.getSize() == 0)
					AddCode("ret");
				else if (currentMethod::returnTypes::.getSize() == 1)
				{
					if (rnode::values::.getSize() == 0)
						AddCode("ret\t$" + Core.Int32::ToString(context::firstReturnRegister));
					else
					{
						Value value = EnsureRegister(CompileExpression([Node] rnode::values[0], freereg, freereg, 0, 0), freereg);
						AddCode("ret\t$" + Core.Int32::ToString(value::regid));
					}
				}
				else
				{
					if (rnode::values::.getSize() == 0)
						AddCode("ret\t$" + Core.Int32::ToString(context::firstReturnRegister) + ", $"
							+ Core.Int32::ToString(context::firstReturnRegister + currentMethod::returnTypes::.getSize() - 1));
					else
					{
						for (int32 i = 0; i < rnode::values::.getSize(); i = i + 1)
							/* TODO: Type */
							MoveValueToRegister(
								CompileExpression([Node] rnode::values[i], freereg + i, freereg + i, 0, 0),
								freereg + i
							);
						AddCode("ret\t$" + Core.Int32::ToString(freereg) + ", $"
							+ Core.Int32::ToString(freereg + rnode::values::.getSize() - 1));
					}
				}
			}
			return 1, freereg;
		}
		else if (node::op == Token::Continue)
		{
			if (context::loopLevel == 0)
				throw new CompilerException("Not in a loop.", node::location);
			int32 ctx = Core.Int32::Parse([Core.String] context::contextType::Peek());
			if (ctx == Context::Finally)
				throw new CompilerException("Control cannot go out of the finally block.", node::location);

			context::continueLabelId = FixJumpTarget(context::continueLabelId);
			if (ctx == Context::TryCatch)
				AddCode("leave\t" + GetLabelName(context::continueLabelId));
			else
				AddCode("jmp\t" + GetLabelName(context::continueLabelId));
			return 1, freereg;
		}
		else if (node::op == Token::Break)
		{
			if (context::loopLevel == 0)
				throw new CompilerException("Not in a loop.", node::location);
			int32 ctx = Core.Int32::Parse([Core.String] context::contextType::Peek());
			if (ctx == Context::Finally)
				throw new CompilerException("Control cannot go out of the finally block.", node::location);

			context::breakLabelId = FixJumpTarget(context::breakLabelId);
			if (ctx == Context::TryCatch)
				AddCode("leave\t" + GetLabelName(context::breakLabelId));
			else
				AddCode("jmp\t" + GetLabelName(context::breakLabelId));
			return 0, freereg;
		}
		else if (node::op == Token::Try)
		{
			TryNode tnode = [TryNode] node;
			int32 endTarget = currentLabelId;
			currentLabelId = currentLabelId + 1;

			if (tnode::finallyNode != null)
			{
				context::tryCatchLevel = context::tryCatchLevel + 1;
				context::contextType::Push([Core.Object] Core.Int32::ToString(Context::TryCatch));
			}

			AddCode(".try {");
			Tab();
			int32 closed = CompileStatement(tnode::body, freereg, context);
			if (closed == 0)
				if (tnode::finallyNode == null)
					AddCode("jmp\t" + GetLabelName(endTarget));
				else
					AddCode("leave\t" + GetLabelName(endTarget));
			Untab();
			AddCode("}");
			for (int32 i = 0; i < tnode::catchNodes::.getSize(); i = i + 1)
			{
				CatchNode cnode = [CatchNode] tnode::catchNodes[i];
				AddCode(".catch(" + cnode::className + " $" + Core.Int32::ToString(freereg) + ") {");
				PushSymbolStack();
				Variable var = new Variable();
				var::regid = freereg;
				var::type = cnode::className;
				([Hash] symbolTable::Peek())::Add(cnode::name, [Core.Object] var);
				Tab();
				int32 closed = CompileStatement(cnode::body, freereg + 1, context);
				if (closed == 0)
					if (tnode::finallyNode == null)
						AddCode("jmp\t" + GetLabelName(endTarget));
					else
						AddCode("leave\t" + GetLabelName(endTarget));
				Untab();
				AddCode("}");
				PopSymbolStack(); 
			}
			if (tnode::finallyNode != null)
			{
				context::tryCatchLevel = context::tryCatchLevel - 1;
				context::contextType::Pop();
				context::finallyLevel = context::finallyLevel + 1;
				context::contextType::Push([Core.Object] Core.Int32::ToString(Context::Finally));

				AddCode(".finally {");
				Tab();
				CompileStatement(tnode::finallyNode, freereg, context);
				AddCode("endfinally");
				Untab();
				AddCode("}");

				context::contextType::Pop();
				context::finallyLevel = context::finallyLevel - 1;
			}
			AddLabel(endTarget);
			return 0, freereg;
		}
		else if (node::op == Token::Throw)
		{
			ThrowNode tnode = [ThrowNode] node;
			Value value = EnsureRegister(ToScalar(CompileList(tnode::exception, freereg, -1)), freereg);
			AddCode("throw\t$" + Core.Int32::ToString(value::regid));
			return 1, freereg;
		}
		else
		{
			CompileList(node, freereg, -1);
			return 0, freereg;
		}
	}

	/* Call node is the only 'expression'-like node that can return multiple values (or zero). */
	/* So don't bother mentioning it many times here */
	/* Save last scalar value to 'lastreg' if 'lastreg' != -1 */
	private function CompileList(Node node, int32 freereg, int32 lastreg) -> Vector
	{
		if (node::op == Token::List)
		{
			ListNode lnode = [ListNode] node;
			Vector ret = new Vector();
			for (int32 i = 0; i < lnode::values::.getSize(); i = i + 1)
			{
				Node node = [Node] lnode::values[i];
				int32 reg = freereg + ret::.getSize();
				if (node::op == Token::Call)
				{
					Vector r = CompileCall(node, reg);
					for (int32 j = 0; j < r::.getSize(); j = j + 1)
						ret::Add(r[j]);
				}
				else if (lastreg != -1 && i + 1 == lnode::values::.getSize()) /* Last scalar */
					ret::Add([Core.Object] EnsureRegister(CompileExpression(node, reg, lastreg, 0, 0), lastreg));
				else /* Ensure value is a register at stack position */
					ret::Add([Core.Object] MoveValueToRegister(CompileExpression(node, reg, reg, 0, 0), reg));
			}
			return ret;
		}
		else if (node::op == Token::Assign)
		{
			BinNode bnode = [BinNode] node;
			if (bnode::left::op != Token::List)
			{
				/* Single operand assign */
				Value left = CompileExpression(bnode::left, freereg, freereg, 0, 0);
				freereg = GetNextFreeRegister(left, freereg);
				if (left::kind & Value::LValue == 0)
					throw new CompilerException("Lvalue expected.", node::location);
				int32 targetreg = freereg;
				if (left::kind & Value::Register > 0)
					targetreg = left::regid;
				Value right = CompileExpression(bnode::right, freereg, targetreg, 0, 0);
				MoveValueToLValue(node, right, left, freereg);
				return Scalar(left);
			}
			else
			{
				Vector left = new Vector();
				ListNode lnode = [ListNode] bnode::left;
				for (int32 i = 0; i < lnode::values::.getSize(); i = i + 1)
				{
					Value value = CompileExpression([Node] lnode::values[i], freereg, freereg, 0, 0);
					freereg = GetNextFreeRegister(value, freereg);
					if (value::kind & Value::LValue == 0)
						throw new CompilerException("Lvalue expected.", node::location);
					left::Add([Core.Object] value);
				}

				/* Optimize: if last element of 'left' is a register,
				   directly store corresponding result in 'right' to that register */
				if (([Value] left[left::.getSize() - 1])::kind & Value::Register > 0)
					lastreg = ([Value] left[left::.getSize() - 1])::regid;
				else
					lastreg = -1;
				Vector right = CompileList(bnode::right, freereg, lastreg);
				if (left::.getSize() != right::.getSize())
					throw new CompilerException("List size unmatch.", node::location);
				/* Move results to left, note the last one must be copied first, due to the optimization above */
				for (int32 i = left::.getSize() - 1; i >= 0; i = i - 1)
					MoveValueToLValue(node, [Value] right[i], [Value] left[i], freereg);
				return left;
			}
		}
		else if (node::op == Token::Call)
			return CompileCall(node, freereg);
		else /* Scalar */
		{
			if (lastreg != -1)
				return Scalar(CompileExpression(node, freereg, lastreg, 0, 0));
			else
				return Scalar(CompileExpression(node, freereg, freereg, 0, 0));
		}
	}

	private function FixJumpTarget(int32 jtarget) -> int32
	{
		if (jtarget == 0)
		{
			currentLabelId = currentLabelId + 1;
			return currentLabelId - 1;
		}
		else
			return jtarget;
	}

	/* Convert types to a unified stack type for doing arithmetic */
	private function UnifyTypes(Node node, Value left, Value right, int32 leftreg, int32 rightreg) -> Value, Value
	{
		Core.String type;
		if (IsConvertible(left, "int8") > 0 && IsConvertible(right, "int8") > 0)
			type = "int8";
		else if (IsConvertible(left, "uint8") > 0 && IsConvertible(right, "uint8") > 0)
			type = "uint8";
		else if (IsConvertible(left, "int16") > 0 && IsConvertible(right, "int16") > 0)
			type = "int16";
		else if (IsConvertible(left, "uint16") > 0 && IsConvertible(right, "uint16") > 0)
			type = "uint16";
		else if (IsConvertible(left, "int32") > 0 && IsConvertible(right, "int32") > 0)
			type = "int32";
		else if (IsConvertible(left, "uint32") > 0 && IsConvertible(right, "uint32") > 0)
			type = "uint32";
		else
			throw new CompilerException("Uncompatible types.", node::location);

		/* If stack type of start type is equal to target stack type, we don't need a conversion,
		   e.g. int8 -> int16, int8 -> int32 */
		Core.String stacktype = GetStackType(type);
		left = EnsureTypedValue(node, left, leftreg, stacktype);
		right = EnsureTypedValue(node, right, rightreg, stacktype);

		return left, right;
	}

	/* Convert to a typed value from its corresponding raw stack value */
	private function FixRawValue(Value value, int32 targetreg) -> Value
	{
		/* TODO: IntegerImmediate value */
		Core.String stacktype = GetStackType(value::type);
		if (value::type::Equals(stacktype) == 0)
		{
			Value ret = EnsureRegister(value, targetreg);
			AddCode("conv\t" + value::type + " $" + Core.Int32::ToString(targetreg) + ", "
				+ stacktype + " $" + Core.Int32::ToString(value::regid));
			value::regid = targetreg;
			return value;
		}
		else
			return value;
	}

	/* Return 'value' */
	private function CompileExpression(Node node, int32 freereg, int32 targetreg, int32 jtarget, int32 jtrue) -> Value
	{
		if (node::op <= Token::BinArith)
		{
			BinNode bnode = [BinNode] node;
			Value left = EnsureRegister(CompileExpression(bnode::left, freereg, freereg, 0, 0), freereg);
			Value right = CompileExpression(bnode::right, freereg + 1, freereg + 1, 0, 0);
			Core.String inst;

			if (left::type::Equals("int") > 0 && right::type::Equals("int32") > 0)
			{
				right = EnsureRegister(right, freereg + 1);
				if (bnode::op == Token::Add)
					inst = "addni";
				else if (bnode::op == Token::Sub)
					inst = "subni";
				else
					throw new CompilerException("Unsupported binary operatior.", node::location);
			}
			else if (IsPrimitiveType(left::type) == 0 || IsPrimitiveType(right::type) == 0)
				return CompileCustomBinaryOperator(node, bnode::op, left, right, freereg);
			else
			{
				if (bnode::op == Token::Add)
					inst = "add";
				else if (bnode::op == Token::Sub)
					inst = "sub";
				else if (bnode::op == Token::Mul)
					inst = "mul";
				else if (bnode::op == Token::Div)
					inst = "div";
				else if (bnode::op == Token::Rem)
					inst = "rem";
				else if (bnode::op == Token::BitAnd)
					inst = "and";
				else if (bnode::op == Token::BitOr)
					inst = "or";
				else if (bnode::op == Token::BitXor)
					inst = "xor";
				else
					throw new CompilerException("Unsupported binary operatior.", node::location);
				left, right = UnifyTypes(node, left, right, freereg, freereg + 1);
				inst = inst + GetTypeSuffix(GetStackType(left::type));
			}

			Value ret = new Value();
			ret::kind = Value::Register;
			ret::regid = targetreg;
			ret::type = left::type;
			
			/* TODO */
			if (right::kind & Value::IntegerImmediate > 0 && left::type::Equals("int32") > 0)
				AddCode(inst + "\t$" + Core.Int32::ToString(targetreg)
					+ ", $" + Core.Int32::ToString(left::regid)
					+ ", " + right::intvalue);
			else
			{
				AddCode(inst + "\t$" + Core.Int32::ToString(targetreg)
					+ ", $" + Core.Int32::ToString(left::regid)
					+ ", $" + Core.Int32::ToString(EnsureRegister(right, freereg + 1)::regid));
				ret = FixRawValue(ret, targetreg);
			}
			return ret;
		}
		else if (node::op <= Token::BinComparison)
		{
			jtarget = FixJumpTarget(jtarget);

			BinNode bnode = [BinNode] node;
			Value left = EnsureRegister(CompileExpression(bnode::left, freereg, freereg, 0, 0), freereg);
			Value right = CompileExpression(bnode::right, freereg + 1, freereg + 1, 0, 0);
			Core.String inst;
			if ((left::type::Equals("int32") > 0 || left::type::Equals("char") > 0) && left::type::Equals(right::type) > 0)
			{
				if (jtrue > 0) /* jump on true */
				{
					if (bnode::op == Token::LT)
						inst = "lt";
					else if (bnode::op == Token::LE)
						inst = "le";
					else if (bnode::op == Token::GT)
						inst = "gt";
					else if (bnode::op == Token::GE)
						inst = "ge";
					else if (bnode::op == Token::EQ)
						inst = "eq";
					else if (bnode::op == Token::NEQ)
						inst = "neq";
					else
						throw new CompilerException("Unsupported comparison operatior.", node::location);
				}
				else /* jump on false */
				{
					if (bnode::op == Token::LT)
						inst = "ge";
					else if (bnode::op == Token::LE)
						inst = "gt";
					else if (bnode::op == Token::GT)
						inst = "le";
					else if (bnode::op == Token::GE)
						inst = "lt";
					else if (bnode::op == Token::EQ)
						inst = "neq";
					else if (bnode::op == Token::NEQ)
						inst = "eq";
					else
						throw new CompilerException("Unsupported comparison operatior.", node::location);
				}
				if (right::kind & Value::IntegerImmediate > 0 && right::intvalue::Equals("0") > 0)
					AddCode("j" + inst + "zi\t$" + Core.Int32::ToString(left::regid) + ", " + GetLabelName(jtarget));
				else
				{
					right = EnsureRegister(right, freereg + 1);
					AddCode("j" + inst + "i\t$" + Core.Int32::ToString(left::regid) + ", $"
						+ Core.Int32::ToString(right::regid) + ", " + GetLabelName(jtarget));
				}
			}
			else if ((IsPrimitiveType(left::type) == 0 || left::type::Equals("int") > 0) && right::type::Equals("int") > 0)
			{
				if (right::kind & Value::Immediate == 0)
					throw new CompilerException("Right hand value should be null.", node::location);
				if (jtrue > 0) /* jump on true */
					if (bnode::op == Token::EQ)
						inst = "jn";
					else if (bnode::op == Token::NEQ)
						inst = "jnn";
					else
						throw new CompilerException("Unsupported comparison operatior.", node::location);
				else /* jump on false */
					if (bnode::op == Token::EQ)
						inst = "jnn";
					else if (bnode::op == Token::NEQ)
						inst = "jn";
					else
						throw new CompilerException("Unsupported comparison operatior.", node::location);
				AddCode(inst + "\t$" + Core.Int32::ToString(left::regid) + ", " + GetLabelName(jtarget));
			}
			else if (bnode::op == Token::Is)
			{
				if (right::kind & Value::Type == 0)
					throw new CompilerException("Not a type.", node::location);
				if (jtrue > 0) /* jump on true */
					inst = "jinst";
				else /* jump on false */
					inst = "jninst";
				AddCode(inst + "\t$" + Core.Int32::ToString(left::regid) + ", " + right::type + ", " + GetLabelName(jtarget));
			}
			else
				throw new CompilerException("Unhandled jcc case.", node::location);
			Value ret = new Value();
			ret::kind = Value::JumpTarget;
			ret::labelid = jtarget;
			ret::type = "int32"; /* HACK: bool type */
			return ret;
		}
		else if (node::op <= Token::BinLogic)
		{
			jtarget = FixJumpTarget(jtarget);

			BinNode bnode = [BinNode] node;
			int32 leftjtrue, rightjtrue;
			int32 leftjtarget, rightjtarget;
			/* Calculate jump target of left/right */
			if (node::op == Token::And)
			{
				if (jtrue > 0)
				{
					leftjtrue = 0;
					leftjtarget = currentLabelId;
					rightjtrue = 1;
					rightjtarget = jtarget;
					currentLabelId = currentLabelId + 1;
				}
				else
				{
					leftjtrue = 0;
					rightjtrue = 0;
					leftjtarget = rightjtarget = jtarget;
				}
			}
			else if (node::op == Token::Or)
			{
				if (jtrue > 0)
				{
					leftjtrue = 1;
					rightjtrue = 1;
					leftjtarget = rightjtarget = jtarget;
				}
				else
				{
					leftjtrue = 1;
					leftjtarget = currentLabelId;
					rightjtrue = 0;
					rightjtarget = jtarget;
					currentLabelId = currentLabelId + 1;
				}
			}
			else
				throw new Core.InvalidOperationException();
			Value left = CompileExpression(bnode::left, freereg, freereg, leftjtarget, leftjtrue);
			Value right = CompileExpression(bnode::right, freereg, freereg, rightjtarget, rightjtrue);
			if (left::kind & Value::JumpTarget == 0 || right::kind & Value::JumpTarget == 0)
				throw new CompilerException("Jump target expected.", node::location); /* TODO */
			if (leftjtarget != jtarget)
				AddLabel(leftjtarget);

			Value ret = new Value();
			ret::kind = Value::JumpTarget;
			ret::labelid = jtarget;
			ret::type = "int32"; /* HACK: bool type */
			return ret;
		}
		else if (node::op <= Token::UnaryOp)
		{
			UnaryNode unode = [UnaryNode] node;
			if (node::op == Token::Deref)
			{
				/* Deference */
				Value value = EnsureRegister(CompileExpression(unode::operand, freereg, freereg, 0, 0), freereg);
				if (value::type::Equals("int") == 0)
					throw new Core.Exception();
				Value ret = new Value();
				ret::kind = Value::Deref | Value::LValue;
				ret::regid = value::regid;
				ret::type = "char";
				return ret;
			}
			else if (node::op == Token::AddressOf)
			{
				Value value = CompileExpression(unode::operand, freereg, freereg, 0, 0);
				if (value::kind & Value::LValue == 0)
					throw new CompilerException("LValue expected.", node::location);
				if (value::kind & Value::Register > 0)
					AddCode("lar\t$" + Core.Int32::ToString(targetreg) + ", $" + Core.Int32::ToString(value::regid));
				else if (value::kind & Value::Field > 0)
				{
					Class classObject = value::classObject;
					Field field = value::field;
					if (field::modifier & Modifier::Static > 0)
						AddCode("las\t$" + Core.Int32::ToString(targetreg) + ", " + classObject::name
							+ "::" + field::name);
					else
						AddCode("laf\t$" + Core.Int32::ToString(targetreg) + ", $" + Core.Int32::ToString(value::regid)
							+ ", " + classObject::name + "::" + field::name);
				}
				else if (value::kind & Value::ArrayElement > 0)
				{
					AddCode("lae\t$" + Core.Int32::ToString(targetreg) + ", $" + Core.Int32::ToString(value::regid)
						+ "($" + Core.Int32::ToString(value::regid2) + ")");
				}
				else
					throw new CompilerException("Unhandled addressof case.", node::location);
				Value ret = new Value();
				ret::kind = Value::Register;
				ret::regid = targetreg;
				ret::type = "int";
				return ret;
			}
			else
			{
				Value value = EnsureRegister(CompileExpression(unode::operand, freereg, targetreg, 0, 0), targetreg);
				if (value::type::Equals("int32") == 0)
					throw new CompilerException("Int32 expected.", node::location); /* TODO */
				Core.String inst;
				if (node::op == Token::Neg)
					inst = "negi";
				else if (node::op == Token::BitNot)
					inst = "noti";
				else
					throw new CompilerException("Unsupported unary operatior.", node::location);
				AddCode(inst + "\t$" + Core.Int32::ToString(targetreg) + ", $" + Core.Int32::ToString(value::regid));
				Value ret = new Value();
				ret::kind = Value::Register;
				ret::regid = targetreg;
				ret::type = value::type;
				return ret;
			}
		}
		else if (node::op == Token::New)
		{
			NewNode nnode = [NewNode] node;
			Class classObject = [Class] classes[nnode::type];
			Method method = [Method] classObject::methods[".ctor"];
			if (method::paramTypes::.getSize() != nnode::parameters::.getSize())
				throw new CompilerException("Invalid number of parameters.", node::location);
			for (int32 i = 0; i < nnode::parameters::.getSize(); i = i + 1)
			{
				Value value = ToScalar(CompileList([Node] nnode::parameters[i], freereg + 2 + i, -1));
				MoveValueToRegister(value, freereg + 2 + i);
				if (value::type::Equals([Core.String] method::paramTypes[i]) == 0)
					throw new CompilerException("Parameter type mismatch.", node::location);
			}
			AddCode("new\t$" + Core.Int32::ToString(freereg) + ", " + classObject::name + "::"
				+ method::name + method::type);
			Value ret = new Value();
			ret::kind = Value::Register;
			ret::regid = freereg;
			ret::type = classObject::name;
			return ret;
		}
		else if (node::op == Token::NewArray)
		{
			NewNode nnode = [NewNode] node;
			if (nnode::parameters::.getSize() != 1)
				throw new CompilerException("Currently only 1 dim array supported.", node::location);

			Value value = EnsureRegister(ToScalar(CompileList([Node] nnode::parameters[0], freereg, -1)), freereg);
			AddCode("newarr\t$" + Core.Int32::ToString(targetreg) + ", " + nnode::type + "($"
				+ Core.Int32::ToString(value::regid) + ")");
			Value ret = new Value();
			ret::kind = Value::Register;
			ret::regid = targetreg;
			ret::type = nnode::type + "[]";
			return ret;
		}
		else if (node::op == Token::Call)
			return ToScalar(CompileCall(node, freereg));
		else if (node::op == Token::Assign)
			return ToScalar(CompileList(node, freereg, -1));
		else if (node::op == Token::TypeCast)
		{
			TypeCastNode tnode = [TypeCastNode] node;
			Value value = EnsureRegister(CompileExpression(tnode::operand, freereg, targetreg, 0, 0), targetreg);
			if (IsPrimitiveType(value::type) > 0)
			{
				/* No boxing/unboxing now */
				if (IsPrimitiveType(tnode::type) == 0)
					throw new CompilerException("No boxing/unboxing now.", node::location);
				value::type = tnode::type;
				return value;
			}
			else
			{
				AddCode("cast\t$" + Core.Int32::ToString(targetreg) + ", $" + Core.Int32::ToString(value::regid)
					+ ", " + tnode::type);
				Value ret = new Value();
				ret::kind = Value::Register;
				ret::regid = targetreg;
				ret::type = tnode::type;
				return ret;
			}
		}
		else if (node::op == Token::ArrayElement)
		{
			ArrayElementNode anode = [ArrayElementNode] node;
			Value array = EnsureRegister(ToScalar(CompileList(anode::array, freereg, -1)), freereg);
			if (array::type::.getLength() > 2 && array::type::SubString(array::type::.getLength() - 2, 2)::Equals("[]") > 0)
			{
				freereg = GetNextFreeRegister(array, freereg);
				Value index = EnsureRegister(ToScalar(CompileList(anode::index, freereg, -1)), freereg);
				Value ret = new Value();
				ret::kind = Value::ArrayElement | Value::LValue;
				ret::regid = array::regid;
				ret::regid2 = index::regid;
				ret::type = array::type::SubString(0, array::type::.getLength() - 2);
				return ret;
			}
			else
			{
				Value index = EnsureRegister(CompileExpression(anode::index, freereg + 1, freereg + 1, 0, 0), freereg + 1);
				Value value = CompileCustomBinaryOperator(node, Token::Array, array, index, freereg);
				return value;
			}
		}
		else if (node::op == Token::Field)
		{
			FieldNode fnode = [FieldNode] node;
			Value object = CompileExpression(fnode::object, freereg, freereg, 0, 0);
			/* TODO */
			if (object::type::SubString(object::type::.getLength() - 2, 2)::Equals("[]") > 0)
			{
				if (fnode::field::Equals("Length") == 0)
					throw new CompilerException("Unknown field.", node::location);
				object = EnsureRegister(object, freereg);
				AddCode("ldlen\t$" + Core.Int32::ToString(targetreg) + ", $" + Core.Int32::ToString(object::regid));
				Value ret = new Value();
				ret::kind = Value::Register;
				ret::regid = targetreg;
				ret::type = "int32";
				return ret;
			}

			Value ret = new Value();
			if (object::kind & Value::Type > 0)
				ret::classObject = object::classObject;
			else
			{
				object = EnsureRegister(object, freereg);
				ret::regid = object::regid;
				ret::classObject = [Class] classes[object::type];
			}

			Field field = ResolveField(ret::classObject, fnode::field);
			if (field != null)
			{
				/* Field */
				ret::kind = Value::Field | Value::LValue;
				ret::field = field;
				ret::type = field::type;
			}
			else
			{
				/* Method */
				ret::kind = Value::Method;
				ret::methods = new Vector();
				/* HACK */
				ResolveMethod(ret::classObject, fnode::field, ret::methods);
			}
			return ret;
		}
		else if (node::op == Token::Ident)
		{
			IdentNode inode = [IdentNode] node;
			int32 found;
			Core.Object classObject;
			if ((found, classObject = classes::Contains(inode::ident)) > 0)
			{
				Value ret = new Value();
				ret::kind = Value::Type;
				ret::classObject = [Class] classObject;
				ret::type = ([Class] classObject)::name;
				return ret;
			}
			else
			{
				Variable variable;
				int32 found;
				variable, found = FindSymbol(inode::ident);
				if (found > 0)
				{
					Value ret = new Value();
					ret::kind = Value::Register | Value::LValue;
					ret::regid = variable::regid;
					ret::type = variable::type;
					return ret;
				}
				else
				{
					Field field = ResolveField(currentClass, inode::ident);
					if (field != null)
					{
						Value ret = new Value();
						ret::kind = Value::Field | Value::LValue;
						ret::regid = 0;
						ret::classObject = currentClass;
						ret::field = [Field] field;
						ret::type = ([Field] field)::type;
						return ret;
					}
					else
					{
						Value ret = new Value();
						ret::kind = Value::Method;
						ret::regid = 0;
						ret::classObject = currentClass;
						ret::methods = new Vector();
						ResolveMethod(currentClass, inode::ident, ret::methods);
						if (ret::methods::.getSize() == 0)
							throw new CompilerException("Unknown ident.", node::location);
						return ret;
					}
				}
			}
		}
		else if (node::op == Token::This)
		{
			if (currentMethod::modifier & Modifier::Static > 0)
				throw new CompilerException("'this' cannot be used in a static method.", node::location);
			Value ret = new Value();
			ret::kind = Value::Register;
			ret::regid = 0;
			ret::type = currentClass::name;
			return ret;
		}
		else if (node::op == Token::Number)
		{
			IntegerNode inode = [IntegerNode] node;
			Value ret = new Value();
			ret::kind = Value::IntegerImmediate;
			ret::intvalue = inode::intvalue;
			ret::type = "int32"; /* FIXME: Should be ret::type = "" */
			return ret;
		}
		else if (node::op == Token::String)
		{
			StringNode snode = [StringNode] node;
			AddCode("ldstr\t$" + Core.Int32::ToString(targetreg) + ", \"" + snode::stringvalue + "\"");
			Value ret = new Value();
			ret::kind = Value::Register;
			ret::regid = targetreg;
			ret::type = "Core.String";
			return ret;
		}
		else if (node::op == Token::Null)
		{
			Value ret = new Value();
			ret::kind = Value::Immediate;
			ret::type = "int";

			return ret;
		}
		else
			throw new CompilerException("INTERNAL: Unhandled expression case.", node::location);
	}

	private function CompileCall(Node node, int32 freereg) -> Vector
	{
		CallNode cnode = [CallNode] node;
		Value methodValue = ToScalar(CompileList(cnode::method, freereg, -1));
		if (methodValue::kind & Value::Method == 0)
			throw new CompilerException("Method expected.", node::location);
		Class classObject = methodValue::classObject;
		Vector methods = methodValue::methods;

		/* Push 'this' if necessary */
		/* TODO: We do not allow overload mixed static/unstatic methods */
		int32 firstreg = freereg;
		if (([Method] methods[0])::modifier & Modifier::Static > 0)
			firstreg = freereg;
		else
		{
			MoveRegisterToRegister(methodValue::regid, freereg, classObject::name);
			firstreg = firstreg + 1;
		}

		/* Evaluate parameters */
		Vector values = new Vector();
		for (int32 i = 0; i < cnode::parameters::.getSize(); i = i + 1)
		{
			Value value = ToScalar(CompileList([Node] cnode::parameters[i], firstreg + i, -1));
			values::Add([Core.Object] EnsureSingleSlotValue(value, firstreg + i));
		}

		Method method = PrepareCall(node, methods, values, firstreg);

		/* Call function */
		Core.String inst;
		if (method::modifier & Modifier::Virtual > 0)
			inst = "callv";
		else
			inst = "call";
		AddCode(inst + "\t$" + Core.Int32::ToString(freereg) + ", " + classObject::name + "::" + method::name + method::type);

		/* Return value */
		Vector ret = new Vector();
		for (int32 i = 0; i < method::returnTypes::.getSize(); i = i + 1)
		{
			Value value = new Value();
			value::kind = Value::Register;
			value::regid = freereg + i;
			value::type = [Core.String] method::returnTypes[i];
			ret::Add([Core.Object] value);
		}
		return ret;
	}

	private function CompileCustomBinaryOperator(Node node, int32 op, Value left, Value right, int32 firstreg) -> Value
	{
		/* TODO: Currently we only try finding the method in the type */
		MoveValueToRegister(left, firstreg);
		MoveValueToRegister(right, firstreg + 1);

		Core.String methodName = GetOperatorMethodName(op);
		if (methodName == null)
			throw new CompilerException("Unsupported operator.", node::location);
		Method method = [Method] ([Class] classes[left::type])::methods[methodName];
		if (method::paramTypes::.getSize() != 2 || method::returnTypes::.getSize() != 1
			|| ([Core.String] method::paramTypes[0])::Equals(left::type) == 0
			|| ([Core.String] method::paramTypes[1])::Equals(right::type) == 0
			|| method::modifier & Modifier::Static == 1)
			throw new CompilerException("Operator parameter error.", node::location); /* TODO */

		AddCode("call\t$" + Core.Int32::ToString(firstreg) + ", " + left::type + "::" + methodName + method::type);
		Value ret = new Value();
		ret::kind = Value::Register;
		ret::regid = firstreg;
		ret::type = [Core.String] method::returnTypes[0];
		return ret;
	}

	/* Returns field and corresponding class which the field is defined in */
	private function ResolveField(Class startClass, Core.String name) -> Field
	{
		Class c = startClass;
		/* HACK: for (;;) */
		/* HACK: bool */
		while (2 > 1)
		{
			Core.Object field;
			int32 found;
			if ((found, field = c::fields::Contains(name)) > 0)
				return [Field] field;
			if (c::baseName::Equals("") > 0)
				return null;
			c = [Class] classes[c::baseName];
		}
	}

	/* Resolves a method by name, append possible candidates to `methods` vector */
	private function ResolveMethod(Class startClass, Core.String name, Vector methods) -> Vector
	{
		if (methods == null)
			methods = new Vector();
		Class c = startClass;
		/* HACK: for (;;) */
		while (2 > 1)
		{
			Vector current = c::methods::FindAll(name);
			for (int32 i = 0; i < current::.getSize(); i = i + 1)
			{
				Method method = [Method] current[i];
				if (method::modifier & Modifier::Override == 0) /* Do not include overridden methods */
				{
					/* HACK: bool */
					int32 ok = 1;
					/* Make sure this method is not overridden by a subclass method */
					for (int32 j = 0; j < methods::.getSize(); j = j + 1)
					{
						Method another = [Method] methods[j];
						if (method::type::Equals(another::type) > 0)
						{
							ok = 0;
							break;
						}
					}
					if (ok > 0)
						methods::Add([Core.Object] method);
				}
			}
			if (c::baseName::Equals("") > 0)
				return methods;
			c = [Class] classes[c::baseName];
		}
	}

	/* Choose best method in `methods`,
	   Ensures `values` are converted to proper types and placed sequentially from `firstreg`
	   Returns best method */
	private function PrepareCall(Node node, Vector methods, Vector values, int32 firstreg) -> Method
	{
		Vector candidates = new Vector();
		/* Check valid candidates */
		for (int32 i = 0; i < methods::.getSize(); i = i + 1)
		{
			Method method = [Method] methods[i];
			if (method::paramTypes::.getSize() == values::.getSize())
			{
				/* HACK: bool */
				int32 ok = 1;
				for (int32 j = 0; j < method::paramTypes::.getSize(); j = j + 1)
					if (IsConvertible([Value] values[j], [Core.String] method::paramTypes[j]) == 0)
					{
						ok = 0;
						break;
					}
				if (ok > 0)
					candidates::Add([Core.Object] method);
			}
		}
		Method method = ChooseBestMethod(node, candidates, values);
		/* Prepare values */
		for (int32 i = 0; i < values::.getSize(); i = i + 1)
			MoveValueToTypedRegister(node, [Value] values[i], firstreg + i, [Core.String] method::paramTypes[i]);
		return method;
	}

	/* S = Given type, T1 = Method 1 type, T2 = Method 2 type
	 * `->` means implicitly convertible
	 * Rules:
	 * 1. If T1 = T2, neither is better.
	 * 2. If S = T1, T1 is better.
	 *    If S = T2, T2 is better.
	 * 3. If T1 -> T2 and not T2 -> T1, T1 is beter.
	 *    If T2 -> T1 and not T1 -> T2, T2 is better.
	 * 4. Otherwise, neither is better.
	 */
	private function ChooseBestMethod(Node node, Vector methods, Vector values) -> Method
	{
		if (methods::.getSize() == 0)
			throw new CompilerException("No method prototype match type of given parameters.", node::location);
		for (int32 i = 0; i < methods::.getSize(); i = i + 1)
		{
			Method current = [Method] methods[i];
			/* HACK: bool */
			int32 ok = 1;
			for (int32 j = 0; j < methods::.getSize(); j = j + 1)
				if (i != j)
				{
					Method another = [Method] methods[j];
					/* HACK: bool */
					int32 better = 0;
					for (int32 k = 0; k < values::.getSize(); k = k + 1)
					{
						Core.String S = ([Value] values[k])::type;
						Core.String T1 = [Core.String] current::paramTypes[k];
						Core.String T2 = [Core.String] another::paramTypes[k];
						if (T1::Equals(T2) > 0)
							continue;
						if (S::Equals(T1) > 0)
						{
							better = 1;
							continue;
						}
						if (S::Equals(T2) > 0)
						{
							better = 0;
							break;
						}
						/* HACK: bool */
						int32 c1 = IsTypeConvertible(T1, T2), c2 = IsTypeConvertible(T2, T1);
						if (c1 > 0 && c2 == 0)
							better = 1;
						else if (c1 == 0 && c2 > 0)
						{
							better = 0;
							break;
						}
					}
					/* Best method must be better than any other method */
					if (better == 0)
					{
						ok = 0;
						break;
					}
				}
			if (ok > 0)
				return current;
		}
		throw new CompilerException("Ambiguous function call.", node::location);
	}
}
