class Location
{
	public Core.String fileName;
	public int32 lineNumber;

	public ToString() -> Core.String
	{
		return fileName + ":" + lineNumber;
	}
}

class ParserType
{
	public Location location;
	public Core.String typestring;
	public Type type;

	public .ctor(Location location)
	{
		this::location = location;
	}
}

class Node
{
	public int32 op;
	Location location;

	public .ctor(Location location)
	{
		this::location = location;
	}
}

class BoolNode: Node
{
	/* HACK: bool */
	public int32 boolvalue;

	public .ctor(Location location)
	{
		this::location = location;
	}
}

class IntegerNode: Node
{
	public Core.String intvalue;

	public .ctor(Location location)
	{
		this::location = location;
	}
}

class StringNode: Node
{
	public Core.String stringvalue;

	public .ctor(Location location)
	{
		this::location = location;
	}
}

class IdentNode: Node
{
	public Core.String ident;

	public .ctor(Location location)
	{
		this::location = location;
	}
}

class FieldNode: Node
{
	public Node object;
	public Core.String field;

	public .ctor(Location location)
	{
		this::location = location;
	}
}

class CallNode: Node
{
	public Node method;
	public Vector parameters;

	public .ctor(Location location)
	{
		this::location = location;
		parameters = new Vector();
	}
}

class NewNode: Node
{
	public ParserType type;
	public Vector parameters;

	public .ctor(Location location)
	{
		this::location = location;
		parameters = new Vector();
	}
}

class ArrayElementNode: Node
{
	public Node array;
	public Node index;

	public .ctor(Location location)
	{
		this::location = location;
	}
}

class UnaryNode: Node
{
	public Node operand;

	public .ctor(Location location)
	{
		this::location = location;
	}
}

class BinNode: Node
{
	public Node left, right;

	public .ctor(Location location)
	{
		this::location = location;
	}
}

class ListNode: Node
{
	public Vector values;

	public .ctor(Location location)
	{
		this::location = location;
		values = new Vector();
	}
}

class DefinitionNode: Node
{
	public ParserType type;
	public Vector names;
	public Vector values;

	public .ctor(Location location)
	{
		this::location = location;
		names = new Vector();
		values = new Vector();
	}
}

class MultipleNode: Node
{
	public Vector nodes;

	public .ctor(Location location)
	{
		this::location = location;
		nodes = new Vector();
	}
}

class TypeCastNode: Node
{
	public ParserType type;
	public Node operand;

	public .ctor(Location location)
	{
		this::location = location;
	}
}

class IfNode: Node
{
	public Node condition;
	public Node trueBody, falseBody;

	public .ctor(Location location)
	{
		this::location = location;
	}
}

class WhileNode: Node
{
	public Node condition;
	public Node body;

	public .ctor(Location location)
	{
		this::location = location;
	}
}

class ForNode: Node
{
	public Node init, condition, update;
	public Node body;

	public .ctor(Location location)
	{
		this::location = location;
	}
}

class ReturnNode: Node
{
	public Vector values;

	public .ctor(Location location)
	{
		this::location = location;
		values = new Vector();
	}
}

class TryNode: Node
{
	public Node body;
	public Vector catchNodes;
	public Node finallyNode;

	public .ctor(Location location)
	{
		this::location = location;
		catchNodes = new Vector();
	}
}

class CatchNode: Node
{
	public ParserType type;
	public Core.String name;
	public Node body;

	public .ctor(Location location)
	{
		this::location = location;
	}
}

class ThrowNode: Node
{
	public Node exception;

	public .ctor(Location location)
	{
		this::location = location;
	}
}

class Field
{
	public Class classObject;
	public int32 modifier;
	public Core.String name;
	public ParserType type;
	public Location location;

	public .ctor(Location location)
	{
		this::location = location;
	}
}

class Method
{
	public Class classObject;
	public int32 modifier;
	public Core.String name;
	public Core.String prototype;
	public Vector paramTypes;
	public Vector paramNames;
	public Vector returnTypes;
	public Vector returnNames;
	public int32 callingConvention;
	public Core.String libraryName, originalName;
	public Node body;
	public Location location;

	public .ctor(Location location)
	{
		this::location = location;

		paramTypes = new Vector();
		paramNames = new Vector();
		returnTypes = new Vector();
		returnNames = new Vector();
	}
}

class Property
{
	public Class classObject;
	public int32 modifier;
	public Core.String name;
	public ParserType type;
	public Method getter;
	public Method setter;
	public Location location;

	public .ctor(Location location)
	{
		this::location = location;
	}
}

class Class
{
	public Core.String name, baseName;
	public Class baseClass;
	public Hash methods;
	public Hash fields;
	public Hash properties;
	public Location location;

	public .ctor(Location location)
	{
		this::location = location;

		methods = new Hash();
		fields = new Hash();
		properties = new Hash();
	}
}

class Modifier
{
	public static int32 Public, Private, Protected;
	public static int32 Static, Virtual, Override, Abstract;
	public static int32 Internal, Native, Interface;
	public static Hash hash;

	public static Parse(Core.String string) -> int32
	{
		/* HACK: int -> int32 */
		int32 found;
		Core.Object value;
		if ((found, value = hash::Contains(string)) > 0)
			return Core.Int32::Parse([Core.String] value);
		else
			return 0;
	}

	public static ToString(int32 modifier) -> Core.String
	{
		/* FIXME: Accessing private members */
		Core.String ret = "";
		for (int32 i = 0; i < hash::Size; i = i + 1)
			if (modifier & Core.Int32::Parse([Core.String] hash::values[i]) > 0)
				if (ret::Equals("") > 0)
					ret = ret + [Core.String] hash::keys[i];
				else
					ret = ret + " " + [Core.String] hash::keys[i];
		return ret;
	}

	public static InitModifier()
	{
		Modifier::Public, Modifier::Private, Modifier::Protected = 1, 2, 4;
		Modifier::Static, Modifier::Virtual, Modifier::Override, Modifier::Abstract = 8, 16, 32, 64;
		Modifier::Internal, Modifier::Native, Modifier::Interface = 128, 256, 512;

		hash = new Hash();
		hash::Add("public", [Core.Object] Core.Int32::ToString(Modifier::Public));
		hash::Add("private", [Core.Object] Core.Int32::ToString(Modifier::Private));
		hash::Add("protected", [Core.Object] Core.Int32::ToString(Modifier::Protected));
		hash::Add("static", [Core.Object] Core.Int32::ToString(Modifier::Static));
		hash::Add("virtual", [Core.Object] Core.Int32::ToString(Modifier::Virtual));
		hash::Add("override", [Core.Object] Core.Int32::ToString(Modifier::Override));
		hash::Add("abstract", [Core.Object] Core.Int32::ToString(Modifier::Abstract));
		hash::Add("internal", [Core.Object] Core.Int32::ToString(Modifier::Internal));
		hash::Add("native", [Core.Object] Core.Int32::ToString(Modifier::Native));
		hash::Add("interface", [Core.Object] Core.Int32::ToString(Modifier::Interface));
	}
}

class CallingConvention
{
	public static int32 Unknown, Stdcall;

	public static ToString(int32 cc) -> Core.String
	{
		if (cc == CallingConvention::Unknown)
			return "unknown";
		else if (cc == CallingConvention::Stdcall)
			return "stdcall";
		return "";
	}

	public static Parse(Core.String cc) -> int32
	{
		if (cc::Equals("unknown") > 0)
			return CallingConvention::Unknown;
		else if (cc::Equals("stdcall") > 0)
			return CallingConvention::Stdcall;
		else
			return 0;
	}

	public static InitCallingConvention()
	{
		CallingConvention::Unknown, CallingConvention::Stdcall = 1, 2;
	}
}
