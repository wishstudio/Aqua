using Core;

class Location
{
	public String fileName;
	public int32 lineNumber;

	public ToString() -> String
	{
		return fileName + ":" + lineNumber;
	}
}

class TypeCache
{
	public Node type;
	public Type cache;

	public (Node type)
	{
		this.type = type;
	}
}

class Node
{
	Location location;

	public (Location location)
	{
		this.location = location;
	}

	public ToType(Compiler compiler) -> Type
	{
		Object type = ToTypeEntity(compiler);
		if (type is Type)
			return [Type] type;
		if (type is Class)
		{
			Class classObject = [Class] type;
			if (classObject.modifier & Modifier.ValueType > 0)
				return new ValueType(classObject);
			else
				return new ClassType(classObject);
		}
		throw new CompilerException("Type expected.", location);
	}

	public virtual ToTypeEntity(Compiler compiler) -> Object
	{
		throw new CompilerException("Type expected.", location);
	}

	public virtual ToMethod(Compiler compiler, int32 freereg) -> MethodReference
	{
		throw new CompilerException("Method expected.", location);
	}

	/* Returns 'Value' or 'Type' */
	public virtual ToEntity(Compiler compiler, int32 freereg, int32 targetreg) -> Object
	{
		return CompileExpression(compiler, freereg, targetreg, 0, false);
	}

	/* TODO: Aqua: Report error on abstract method invocation */
	public virtual CompileExpression(Compiler compiler, int32 freereg, int32 targetreg, int32 jtarget, bool jtrue) -> Value
	{
		throw new CompilerException("INTERNAL EXCEPTION.", location);
	}

	/* Save last scalar value to 'lastreg' if 'lastreg' != -1 */
	public virtual CompileList(Compiler compiler, int32 freereg, int32 lastreg) -> Vector
	{
		if (lastreg != -1)
			return compiler.Scalar(CompileExpression(compiler, freereg, lastreg, 0, false));
		else
			return compiler.Scalar(CompileExpression(compiler, freereg, freereg, 0, false));
	}

	/* Returns whether the statement block is fully closed (has return statements in all possible control flows) */
	/* Returns 'closed' and 'nextfreereg' */
	private virtual CompileStatement(Compiler compiler, int32 freereg, Context context) -> int32, int32
	{
		CompileList(compiler, freereg, -1);
		return 0, freereg;
	}
}

class NullNode: Node
{
	public (Location location)
	{
		this.location = location;
	}

	public override CompileExpression(Compiler compiler, int32 freereg, int32 targetreg, int32 jtarget, bool jtrue) -> Value
	{
		return new NullValue(location);
	}
}

class BoolNode: Node
{
	public bool boolvalue;

	public (Location location)
	{
		this.location = location;
	}

	public override CompileExpression(Compiler compiler, int32 freereg, int32 targetreg, int32 jtarget, bool jtrue) -> Value
	{
		return new BoolValue(location, boolvalue);
	}
}

class IntegerNode: Node
{
	public String intvalue;

	public (Location location)
	{
		this.location = location;
	}

	public override CompileExpression(Compiler compiler, int32 freereg, int32 targetreg, int32 jtarget, bool jtrue) -> Value
	{
		return new IntegerValue(location, intvalue);
	}
}

class StringNode: Node
{
	public String stringvalue;

	public (Location location)
	{
		this.location = location;
	}

	public override CompileExpression(Compiler compiler, int32 freereg, int32 targetreg, int32 jtarget, bool jtrue) -> Value
	{
		/* TODO: StringValue */
		compiler.AddCode("ldstr\t$" + targetreg + ", \"" + stringvalue + "\"");
		/* TODO */
		Class stringClass = [Class] ([Namespace] compiler.Root.children["Core"]).children["String"];
		return new RegisterValue(location, targetreg, new ClassType(stringClass));
	}
}

class ThisNode: Node
{
	public (Location location)
	{
		this.location = location;
	}

	public override CompileExpression(Compiler compiler, int32 freereg, int32 targetreg, int32 jtarget, bool jtrue) -> Value
	{
		if (compiler.CurrentMethod.modifier & Modifier.Static > 0)
			throw new CompilerException("'this' cannot be used in a static method.", location);
		return new RegisterValue(location, 0, new ClassType(compiler.CurrentClass));
	}
}

class IdentNode: Node
{
	private String ident;

	public (Location location, String ident)
	{
		this.location = location;
		this.ident = ident;
	}

	public override ToTypeEntity(Compiler compiler) -> Object
	{
		Vector namespaces = compiler.CurrentSourceFile.namespaces;
		for (int32 i = 0; i < namespaces.Size; i = i + 1)
		{
			int32 found;
			Object object;
			if ((found, object = ([Namespace] namespaces[i]).children.Contains(ident)) > 0)
				return object;
		}

		throw new CompilerException("Unknown identifier \"" + ident + "\".", location);
	}

	public override ToEntity(Compiler compiler, int32 freereg, int32 targetreg) -> Object
	{
		Variable variable;
		int32 found;
		variable, found = compiler.FindSymbol(ident);
		if (found > 0)
			return new VariableValue(location, variable.regid, variable.type);

		Field field = compiler.ResolveField(compiler.CurrentClass, ident);
		if (field != null)
			return new FieldValue(location, 0, field, compiler.ResolveType(field.type));

		Property property = compiler.ResolveProperty(compiler.CurrentClass, ident);
		if (property != null)
			return new PropertyValue(location, 0, property, compiler.ResolveType(property.type));

		return ToTypeEntity(compiler);
	}

	public override ToMethod(Compiler compiler, int32 freereg) -> MethodReference
	{
		/* HACK */
		Vector methods = new Vector();
		compiler.ResolveMethod(compiler.CurrentClass, ident, methods);
		if (methods.Size > 0)
			return new MethodReference(location, 0, methods);

		throw new CompilerException("Method expected.", location);
	}

	public override CompileExpression(Compiler compiler, int32 freereg, int32 targetreg, int32 jtarget, bool jtrue) -> Value
	{
		Object value = ToEntity(compiler, freereg, targetreg);
		if (value is Value)
			return [Value] value;

		throw new CompilerException("Value expected.", location);
	}
}

class FieldNode: Node
{
	private Node object;
	private String field;

	public (Location location, Node object, String field)
	{
		this.location = location;
		this.object = object;
		this.field = field;
	}

	private ResolveObject(Compiler compiler, int32 freereg, Object object) -> Class, int32
	{
		int32 regid;
		Class classObject = null;
		if (object is Class)
			classObject = [Class] object;
		else if (object is Value)
		{
			RegisterValue v = ([Value] object).EnsureRegister(compiler, freereg);
			Type type = ([Value] object).type;
			regid = v.regid;
			if (type is ClassType)
				classObject = ([ClassType] type).Class;
			else if (type is ValueType)
				classObject = ([ValueType] type).Class;
			else if (type is PointerType && ([PointerType] type).ValueType is ValueType)
				classObject = ([ValueType] ([PointerType] type).ValueType).Class;
		}
		return classObject, regid;
	}

	public ToTypeEntityInternal(Compiler compiler, Object objectEntity) -> Object
	{
		int32 found;
		Object object;
		if (objectEntity is Namespace)
			if ((found, object = ([Namespace] objectEntity).children.Contains(field)) > 0)
				return object;
		throw new CompilerException("Unknown field member \"" + this.field + "\".", location);
	}

	public override ToTypeEntity(Compiler compiler) -> Object
	{
		return ToTypeEntityInternal(compiler, object.ToTypeEntity(compiler));
	}

	public override ToEntity(Compiler compiler, int32 freereg, int32 targetreg) -> Object
	{
		Object object = this.object.ToEntity(compiler, freereg, freereg);

		/* TODO */
		if (object is Value && ([Value] object).type is ArrayType)
		{
			if (field.Equals("Length") == 0)
				throw new CompilerException("Unknown field.", location);
			RegisterValue v = ([Value] object).EnsureRegister(compiler, freereg);
			compiler.AddCode("ldlen\t$" + targetreg + ", $" + v.regid);
			return new RegisterValue(location, targetreg, Type.Int32);
		}

		Class classObject;
		int32 regid;
		classObject, regid = ResolveObject(compiler, freereg, object);

		if (classObject != null)
		{
			Field field = compiler.ResolveField(classObject, this.field);
			if (field != null)
				return new FieldValue(location, regid, field, compiler.ResolveType(field.type));

			Property property = compiler.ResolveProperty(classObject, this.field);
			if (property != null)
				return new PropertyValue(location, regid, property, compiler.ResolveType(property.type));
		}

		return ToTypeEntityInternal(compiler, object);
	}

	public override ToMethod(Compiler compiler, int32 freereg) -> MethodReference
	{
		Object object = this.object.ToEntity(compiler, freereg, freereg);

		Class classObject;
		int32 regid;
		classObject, regid = ResolveObject(compiler, freereg, object);

		if (classObject != null)
		{
			/* HACK */
			Vector methods = new Vector();
			compiler.ResolveMethod(classObject, this.field, methods);
			if (methods.Size > 0)
				return new MethodReference(location, regid, methods);
		}

		throw new CompilerException("Unknown method.", location);
	}

	public override CompileExpression(Compiler compiler, int32 freereg, int32 targetreg, int32 jtarget, bool jtrue) -> Value
	{
		Object value = ToEntity(compiler, freereg, targetreg);
		if (value is Value)
			return [Value] value;

		throw new CompilerException("Value expected.", location);
	}
}

class ArrayTypeNode: Node
{
	private Node object;

	public (Location location, Node object)
	{
		this.location = location;
		this.object = object;
	}

	public override ToTypeEntity(Compiler compiler) -> Object
	{
		Type elementType = object.ToType(compiler);
		return new ArrayType(elementType);
	}
}

class PointerTypeNode: Node
{
	private Node object;

	public (Location location, Node object)
	{
		this.location = location;
		this.object = object;
	}

	public override ToTypeEntity(Compiler compiler) -> Object
	{
		Type valueType = object.ToType(compiler);
		return new PointerType(valueType);
	}
}

class PrimitiveTypeNode: Node
{
	public Type type;

	public (Location location, Type type)
	{
		this.location = location;
		this.type = type;
	}

	public override ToTypeEntity(Compiler compiler) -> Object
	{
		return type;
	}
}

class ArrayElementNode: Node
{
	public Node array;
	public Node index;

	public (Location location)
	{
		this.location = location;
	}

	public override CompileExpression(Compiler compiler, int32 freereg, int32 targetreg, int32 jtarget, bool jtrue) -> Value
	{
		RegisterValue array = this.array.CompileExpression(compiler, freereg, freereg, 0, false).EnsureRegister(compiler, freereg);
		if (array.type is ArrayType)
		{
			freereg = array.GetNextFreeRegister(freereg);
			RegisterValue index = this.index.CompileExpression(compiler, freereg, freereg, 0, false)
				.EnsureRegister(compiler, freereg);
			return new ArrayElementValue(location, array.regid, index.regid, ([ArrayType] array.type).ElementType);
		}
		else
		{
			RegisterValue index = this.index.CompileExpression(compiler, freereg + 1, freereg + 1, 0, false)
				.EnsureRegister(compiler, freereg + 1);
			return compiler.CompileCustomBinaryOperator(location, Token.Array, array, index, freereg);
		}
	}
}

class TypeCastNode: Node
{
	public Node type;
	public Node operand;

	public (Location location)
	{
		this.location = location;
	}

	public override CompileExpression(Compiler compiler, int32 freereg, int32 targetreg, int32 jtarget, bool jtrue) -> Value
	{
		RegisterValue value = operand.CompileExpression(compiler, freereg, targetreg, 0, false).EnsureRegister(compiler, targetreg);
		Type type = this.type.ToType(compiler);
		/* HACK: Workaround */
		if ((value.type is PointerType || value.type is IntType) && (type is PointerType || type is IntType))
		{
			value.type = type;
			return value;
		}
		else if (value.type is PointerType && type is PointerType)
		{
			value.type = type;
			return value;
		}
		else if (value.type is PrimitiveType)
		{
			/* No boxing/unboxing now */
			if (type is PrimitiveType)
			{
				value.type = type;
				return value;
			}
			else
				throw new CompilerException("No boxing/unboxing now.", location);
		}
		else
		{
			compiler.AddCode("cast\t$" + targetreg + ", $" + value.regid + ", " + type.ToString());
			return new RegisterValue(location, targetreg, type);
		}
	}
}

class DereferenceNode: Node
{
	public Node operand;

	public (Location location)
	{
		this.location = location;
	}

	public override CompileExpression(Compiler compiler, int32 freereg, int32 targetreg, int32 jtarget, bool jtrue) -> Value
	{
		RegisterValue value = operand.CompileExpression(compiler, freereg, freereg, 0, false).EnsureRegister(compiler, freereg);
		/* HACK: Temporary workaround */
		if (value.type is IntType)
			return new DerefValue(location, value.regid, Type.Char);
		else if (value.type is PointerType)
			return new DerefValue(location, value.regid, ([PointerType] value.type).ValueType);
		else
			throw new CompilerException("Not a pointer.", location);
	}
}

class AddressOfNode: Node
{
	public Node operand;

	public (Location location)
	{
		this.location = location;
	}

	public override CompileExpression(Compiler compiler, int32 freereg, int32 targetreg, int32 jtarget, bool jtrue) -> Value
	{
		Value value = operand.CompileExpression(compiler, freereg, freereg, 0, false);
		/* TODO */
		Type type;
		if (value is VariableValue)
		{
			VariableValue v = [VariableValue] value;
			compiler.AddCode("lar\t$" + targetreg + ", $" + v.regid);
			type = v.type;
		}
		else if (value is FieldValue)
		{
			FieldValue v = [FieldValue] value;
			Field field = v.field;
			if (field.modifier & Modifier.Static > 0)
				compiler.AddCode("las\t$" + targetreg + ", " + field.classObject.name + "::" + field.name);
			else
				compiler.AddCode("laf\t$" + targetreg + ", $" + v.regid + ", " + field.classObject.name + "::" + field.name);
			type = v.type;
		}
		else if (value is ArrayElementValue)
		{
			ArrayElementValue v = [ArrayElementValue] value;
			compiler.AddCode("lae\t$" + targetreg + ", $" + v.regid + "($" + v.regid2 + ")");
			type = v.type;
		}
		else
			throw new CompilerException("LValue expected.", location);
		return new RegisterValue(location, targetreg, new PointerType(type));
	}
}

class UnaryNode: Node
{
	public int32 op;
	public Node operand;

	public (Location location)
	{
		this.location = location;
	}

	public override CompileExpression(Compiler compiler, int32 freereg, int32 targetreg, int32 jtarget, bool jtrue) -> Value
	{
		/* TODO: Constant folding */
		RegisterValue value = operand.CompileExpression(compiler, freereg, targetreg, 0, false).EnsureRegister(compiler, targetreg);
		if (value.type.StackType.Equals(Type.Int32) > 0 || value.type.StackType.Equals(Type.UInt32) > 0)
		{
			String inst;
			if (op == Token.Neg)
				inst = "negi";
			else if (op == Token.BitNot)
				inst = "noti";
			else
				throw new Exception();
			compiler.AddCode(inst + "\t$" + targetreg + ", $" + value.regid);
			return compiler.FixRawValue(new RegisterValue(location, targetreg, value.type), targetreg);
		}
		else
			throw new CompilerException("Int32 expected.", location); /* TODO */
	}
}

class BinNode: Node
{
	public int32 op;
	public Node left, right;

	public (Location location)
	{
		this.location = location;
	}
}

class BinArithNode: BinNode
{
	public (Location location)
	{
		this.location = location;
	}

	private GetNumOpcode(int32 op) -> String
	{
		if (op == Token.Add)
			return "add";
		else if (op == Token.Sub)
			return "sub";
		else if (op == Token.Mul)
			return "mul";
		else if (op == Token.Div)
			return "div";
		else if (op == Token.Rem)
			return "rem";
		else if (op == Token.BitAnd)
			return "and";
		else if (op == Token.BitOr)
			return "or";
		else if (op == Token.BitXor)
			return "xor";
		else
			throw new Exception();
	}

	public override CompileExpression(Compiler compiler, int32 freereg, int32 targetreg, int32 jtarget, bool jtrue) -> Value
	{
		Value left = this.left.CompileExpression(compiler, freereg, freereg, 0, false)
			.EnsureSingleSlot(compiler, freereg);

		Value right = this.right.CompileExpression(compiler, freereg + 1, freereg + 1, 0, false)
			.EnsureSingleSlot(compiler, freereg + 1);

		if (left.type is PrimitiveType && right.type is PrimitiveType)
		{
			left, right = compiler.UnifyTypes(location, left, right, freereg, freereg + 1);

			String inst = GetNumOpcode(op) + left.type.StackType.Suffix;

			/* TODO: Constant folding */
			if (left is IntegerValue
				&& (op == Token.Add || op == Token.Mul || op == Token.BitAnd || op == Token.BitOr || op == Token.BitXor))
			{
				RegisterValue r = right.EnsureRegister(compiler, freereg + 1);
				compiler.AddCode(inst + "\t$" + targetreg + ", $" + r.regid + ", " + ([IntegerValue] left).value);
			}
			else if (right is IntegerValue)
			{
				RegisterValue l = left.EnsureRegister(compiler, freereg);
				compiler.AddCode(inst + "\t$" + targetreg + ", $" + l.regid + ", " + ([IntegerValue] right).value);
			}
			else
			{
				RegisterValue l = left.EnsureRegister(compiler, freereg);
				RegisterValue r = right.EnsureRegister(compiler, freereg + 1);
				compiler.AddCode(inst + "\t$" + targetreg + ", $" + l.regid + ", $" + r.regid);
			}
			return compiler.FixRawValue(new RegisterValue(location, targetreg, left.type), targetreg);
		}
		else if (left.type is PointerType)
		{
			RegisterValue l = left.EnsureRegister(compiler, freereg);
			RegisterValue r = right.ToTypedRegister(compiler, freereg + 1, freereg + 1, Type.Int32);
			Type valueType = ([PointerType] left.type).ValueType;
			compiler.AddCode("addp\t$" + targetreg + ", $" + l.regid + ", $" + r.regid + ", " + valueType.ToString());
			return new RegisterValue(location, targetreg, left.type);
		}
		else if (left.type is IntType)
		{
			/* HACK: Temporary workaround: int */
			if (right.CanImplicitlyConvertTo(Type.Int32))
			{}
			else
				throw new CompilerException("int +/- int32 only.", location);
			String inst;
			if (op == Token.Add)
				inst = "addni";
			else if (op == Token.Sub)
				inst = "subni";
			else
				throw new CompilerException("Unsupported int operator.", location);
			RegisterValue l = left.EnsureRegister(compiler, freereg);
			RegisterValue r = right.EnsureRegister(compiler, freereg + 1);
			compiler.AddCode(inst + "\t$" + targetreg + ", $" + l.regid + ", $" + r.regid);
			return new RegisterValue(location, targetreg, Type.Int);
		}
		else
			return compiler.CompileCustomBinaryOperator(location, op, left, right, freereg);
	}
}

class BinComparisonNode: BinNode
{
	public (Location location)
	{
		this.location = location;
	}

	private GetNumOpcode(bool jtrue) -> String
	{
		if (jtrue)
		{
			if (op == Token.LT)
				return "lt";
			else if (op == Token.LE)
				return "le";
			else if (op == Token.GT)
				return "gt";
			else if (op == Token.GE)
				return "ge";
			else if (op == Token.EQ)
				return "eq";
			else if (op == Token.NEQ)
				return "neq";
		}
		else
		{
			if (op == Token.LT)
				return "ge";
			else if (op == Token.LE)
				return "gt";
			else if (op == Token.GT)
				return "le";
			else if (op == Token.GE)
				return "lt";
			else if (op == Token.EQ)
				return "neq";
			else if (op == Token.NEQ)
				return "eq";
		}
		throw new Exception();
	}

	private GetNullOpcode(bool jtrue) -> String
	{
		if (jtrue)
		{
			if (op == Token.EQ)
				return "n";
			else if (op == Token.NEQ)
				return "nn";
		}
		else
		{
			if (op == Token.EQ)
				return "nn";
			else if (op == Token.NEQ)
				return "n";
		}
		throw new Exception();
	}

	private GetRefOpcode(bool jtrue) -> String
	{
		if (jtrue)
		{
			if (op == Token.RefEQ)
				return "eq";
			else if (op == Token.RefNEQ)
				return "neq";
		}
		else
		{
			if (op == Token.RefEQ)
				return "neq";
			else if (op == Token.RefNEQ)
				return "eq";
		}
		throw new Exception();
	}

	public override CompileExpression(Compiler compiler, int32 freereg, int32 targetreg, int32 jtarget, bool jtrue) -> Value
	{
		jtarget = compiler.FixJumpTarget(jtarget);

		Value left = this.left.CompileExpression(compiler, freereg, freereg, 0, false)
			.EnsureSingleSlot(compiler, freereg);

		Value right = this.right.CompileExpression(compiler, freereg + 1, freereg + 1, 0, false)
			.EnsureSingleSlot(compiler, freereg + 1);

		if (left.type is PrimitiveType && right.type is PrimitiveType)
		{
			left, right = compiler.UnifyTypes(location, left, right, freereg, freereg + 1);

			if (left.type.StackType.Equals(Type.Int32) > 0 || left.type.StackType.Equals(Type.UInt32) > 0)
			{
				if (left is IntegerValue && ([IntegerValue] left).value.Equals("0") > 0)
				{
					/* HACK: not */
					if (jtrue)
						jtrue = false;
					else
						jtrue = true;
					RegisterValue r = right.EnsureRegister(compiler, freereg + 1);
					compiler.AddCode("j" + GetNumOpcode(jtrue) + "zi\t$" + r.regid + ", " + compiler.GetLabelName(jtarget));
					return new JumpTargetValue(location, jtarget);
				}
				else if (right is IntegerValue && ([IntegerValue] right).value.Equals("0") > 0)
				{
					RegisterValue l = left.EnsureRegister(compiler, freereg);
					compiler.AddCode("j" + GetNumOpcode(jtrue) + "zi\t$" + l.regid + ", " + compiler.GetLabelName(jtarget));
					return new JumpTargetValue(location, jtarget);
				}
				RegisterValue l = left.EnsureRegister(compiler, freereg);
				RegisterValue r = right.EnsureRegister(compiler, freereg + 1);
				compiler.AddCode("j" + GetNumOpcode(jtrue) + left.type.StackType.Suffix + "\t$" + l.regid + ", $" + r.regid
					+ ", " + compiler.GetLabelName(jtarget));
				return new JumpTargetValue(location, jtarget);
			}
			else
				throw new CompilerException("Unsupported comparison type.", location);
		}

		if (left.type is ReferenceType && right.type is ReferenceType)
		{
			if ((left is NullValue || right is NullValue)
				&& (op == Token.EQ || op == Token.NEQ || op == Token.RefEQ || op == Token.RefNEQ))
			{
				if (left is NullValue)
				{
					RegisterValue r = right.EnsureRegister(compiler, freereg + 1);
					compiler.AddCode("j" + GetNullOpcode(jtrue) + "\t$" + r.regid + ", " + compiler.GetLabelName(jtarget));
					return new JumpTargetValue(location, jtarget);
				}
				if (right is NullValue)
				{
					RegisterValue l = left.EnsureRegister(compiler, freereg);
					compiler.AddCode("j" + GetNullOpcode(jtrue) + "\t$" + l.regid + ", " + compiler.GetLabelName(jtarget));
					return new JumpTargetValue(location, jtarget);
				}
			}
			if (op == Token.RefEQ || op == Token.RefNEQ)
			{
				RegisterValue l = left.EnsureRegister(compiler, freereg);
				RegisterValue r = right.EnsureRegister(compiler, freereg + 1);
				compiler.AddCode("j" + GetRefOpcode(jtrue) + "a\t$" + l.regid + ", $" + r.regid
					+ ", " + compiler.GetLabelName(jtarget));
				return new JumpTargetValue(location, jtarget);
			}
		}

		return compiler.CompileCustomBinaryOperator(location, op, left, right, freereg);
	}
}

class IsNode: Node
{
	public Node value, type;
	public (Location location)
	{
		this.location = location;
	}

	public override CompileExpression(Compiler compiler, int32 freereg, int32 targetreg, int32 jtarget, bool jtrue) -> Value
	{
		jtarget = compiler.FixJumpTarget(jtarget);

		RegisterValue value = this.value.CompileExpression(compiler, freereg, freereg, 0, false).EnsureRegister(compiler, freereg);
		Type type = this.type.ToType(compiler);
		String inst;
		if (jtrue)
			inst = "jinst";
		else
			inst = "jninst";
		compiler.AddCode(inst + "\t$" + value.regid + ", " + type.ToString() + ", " + compiler.GetLabelName(jtarget));

		return new JumpTargetValue(location, jtarget);
	}
}

class BinLogicNode: BinNode
{
	public (Location location)
	{
		this.location = location;
	}

	public override CompileExpression(Compiler compiler, int32 freereg, int32 targetreg, int32 jtarget, bool jtrue) -> Value
	{
		jtarget = compiler.FixJumpTarget(jtarget);

		bool leftjtrue, rightjtrue;
		int32 leftjtarget, rightjtarget;
		/* Calculate jump target of left/right */
		if (op == Token.And)
		{
			if (jtrue)
			{
				leftjtrue = false;
				leftjtarget = compiler.GetNextLabelId();
				rightjtrue = true;
				rightjtarget = jtarget;
			}
			else
			{
				leftjtrue = false;
				rightjtrue = false;
				leftjtarget = rightjtarget = jtarget;
			}
		}
		else if (op == Token.Or)
		{
			if (jtrue)
			{
				leftjtrue = true;
				rightjtrue = true;
				leftjtarget = rightjtarget = jtarget;
			}
			else
			{
				leftjtrue = true;
				leftjtarget = compiler.GetNextLabelId();
				rightjtrue = false;
				rightjtarget = jtarget;
			}
		}
		else
			throw new InvalidOperationException();
		left.CompileExpression(compiler, freereg, freereg, leftjtarget, leftjtrue)
			.ToJumpTarget(compiler, freereg, leftjtarget, leftjtrue);
		right.CompileExpression(compiler, freereg, freereg, rightjtarget, rightjtrue)
			.ToJumpTarget(compiler, freereg, rightjtarget, rightjtrue);
		if (leftjtarget != jtarget)
			compiler.AddLabel(leftjtarget);

		return new JumpTargetValue(location, jtarget);
	}
}

class NotNode: Node
{
	public Node value;

	public (Location location, Node value)
	{
		this.location = location;
		this.value = value;
	}

	public override CompileExpression(Compiler compiler, int32 freereg, int32 targetreg, int32 jtarget, bool jtrue) -> Value
	{
		jtarget = compiler.FixJumpTarget(jtarget);

		/* HACK: not */
		if (jtrue)
			jtrue = false;
		else
			jtrue = true;
		return value.CompileExpression(compiler, freereg, freereg, jtarget, jtrue).ToJumpTarget(compiler, freereg, jtarget, jtrue);
	}
}

class NewNode: Node
{
	public Node type;
	public Vector parameters;

	public (Location location)
	{
		this.location = location;
		parameters = new Vector();
	}

	public override CompileExpression(Compiler compiler, int32 freereg, int32 targetreg, int32 jtarget, bool jtrue) -> Value
	{
		Type t = type.ToType(compiler);
		/* HACK: not */
		if (t is ClassType)
		{}
		else
			throw new CompilerException("Not a class type", location);
		ClassType type = [ClassType] t;
		Class classObject = type.Class;
		/* HACK */
		Vector methods = compiler.ResolveMethodInClass(classObject, ".ctor", null);
		Vector values = new Vector();
		for (int32 i = 0; i < parameters.Size; i = i + 1)
		{
			Value value = ([Node] parameters[i]).CompileExpression(compiler, freereg + 2 + i, freereg + 2 + i, 0, false);
			values.Add(value.EnsureSingleSlot(compiler, freereg + 2 + i));
		}
		Method method = compiler.PrepareCall(location, methods, values, freereg + 2);
		compiler.AddCode("new\t$" + freereg + ", " + compiler.GetMethodSignature(method));
		return new RegisterValue(location, freereg, type);
	}
}

class NewArrayNode: Node
{
	public Node type;
	public Node parameter;

	public (Location location)
	{
		this.location = location;
	}

	public override CompileExpression(Compiler compiler, int32 freereg, int32 targetreg, int32 jtarget, bool jtrue) -> Value
	{
		RegisterValue value = parameter.CompileExpression(compiler, freereg, freereg, 0, false).ToFreeRegister(compiler, freereg);
		Type elementType = type.ToType(compiler);
		compiler.AddCode("newarr\t$" + targetreg + ", " + elementType.ToString() + "($" + value.regid + ")");
		return new RegisterValue(location, targetreg, new ArrayType(elementType));
	}
}

class ListNode: Node
{
	public Vector values;

	public (Location location)
	{
		this.location = location;
		values = new Vector();
	}

	public override CompileExpression(Compiler compiler, int32 freereg, int32 targetreg, int32 jtarget, bool jtrue) -> Value
	{
		return compiler.ToScalar(CompileList(compiler, freereg, -1));
	}

	public override CompileList(Compiler compiler, int32 freereg, int32 lastreg) -> Vector
	{
		Vector ret = new Vector();
		for (int32 i = 0; i < values.Size; i = i + 1)
		{
			Node node = [Node] values[i];
			int32 reg = freereg + ret.Size;
			/* TODO */
			if (node is CallNode)
			{
				Vector r = node.CompileList(compiler, reg, -1);
				for (int32 j = 0; j < r.Size; j = j + 1)
					ret.Add(r[j]);
			}
			else if (lastreg != -1 && i + 1 == values.Size) /* Last scalar */
				ret.Add(node.CompileExpression(compiler, reg, lastreg, 0, false).EnsureRegister(compiler, lastreg));
			else /* Ensure value is a register at stack position */
				ret.Add(node.CompileExpression(compiler, reg, reg, 0, false).ToFreeRegister(compiler, reg));
		}
		return ret;
	}
}

class AssignNode: ListNode
{
	public Node left, right;

	public (Location location)
	{
		this.location = location;
	}

	public override CompileList(Compiler compiler, int32 freereg, int32 lastreg) -> Vector
	{
		if (this.left is ListNode)
		{
			Vector left = new Vector();
			ListNode lnode = [ListNode] this.left;
			for (int32 i = 0; i < lnode.values.Size; i = i + 1)
			{
				Value value = ([Node] lnode.values[i]).CompileExpression(compiler, freereg, freereg, 0, false);
				freereg = value.GetNextFreeRegister(freereg);
				/* HACK: not */
				if (value is LValue)
				{}
				else
					throw new CompilerException("Lvalue expected.", lnode.location);
				left.Add(value);
			}

			/* Optimize: if last element of 'left' is a variable,
			   directly store corresponding result in 'right' to that register */
			if (left[left.Size - 1] is VariableValue)
				lastreg = ([VariableValue] left[left.Size - 1]).regid;
			else
				lastreg = -1;
			Vector right = this.right.CompileList(compiler, freereg, lastreg);
			if (left.Size != right.Size)
				throw new CompilerException("List size unmatch.", location);
			/* Move results to left, note the last one must be copied first, due to the optimization above */
			for (int32 i = left.Size - 1; i >= 0; i = i - 1)
				([Value] right[i]).ToLValue(compiler, [LValue] left[i], freereg);
			return left;
		}
		else
		{
			/* Single operand assign */
			Value l = this.left.CompileExpression(compiler, freereg, freereg, 0, false);
			/* HACK: not */
			if (l is LValue)
			{}
			else
				throw new CompilerException("Lvalue expected.", this.left.location);

			LValue left = [LValue] l;
			freereg = l.GetNextFreeRegister(freereg);
			int32 targetreg = freereg;
			if (left is VariableValue)
				targetreg = ([VariableValue] left).regid;
			Value right = this.right.CompileExpression(compiler, freereg, targetreg, 0, false);
			right.ToLValue(compiler, left, freereg);
			return compiler.Scalar(left);
		}
	}
}

class CallNode: ListNode
{
	public Node method;
	public Vector parameters;

	public (Location location)
	{
		this.location = location;
		parameters = new Vector();
	}

	public override CompileList(Compiler compiler, int32 freereg, int32 lastreg) -> Vector
	{
		MethodReference methodReference = method.ToMethod(compiler, freereg);
		Vector methods = ([MethodReference] methodReference).methods;
		Class classObject = ([Method] methods[0]).classObject;

		/* Push 'this' if necessary */
		/* TODO: We do not allow overload mixed static/unstatic methods */
		int32 firstreg = freereg;
		if (([Method] methods[0]).modifier & Modifier.Static > 0)
			firstreg = freereg;
		else
		{
			(new RegisterValue(methodReference.location, ([MethodReference] methodReference).regid, new ClassType(classObject)))
				.ToFreeRegister(compiler, freereg);
			firstreg = firstreg + 1;
		}

		/* Evaluate parameters */
		Vector values = new Vector();
		for (int32 i = 0; i < parameters.Size; i = i + 1)
		{
			Value value = ([Node] parameters[i]).CompileExpression(compiler, firstreg + i, firstreg + i, 0, false);
			values.Add(value.EnsureSingleSlot(compiler, firstreg + i));
		}

		Method method = compiler.PrepareCall(location, methods, values, firstreg);

		/* Call function */
		String inst;
		if (method.modifier & Modifier.Virtual > 0 || method.modifier & Modifier.Abstract > 0)
			inst = "callv";
		else
			inst = "call";
		compiler.AddCode(inst + "\t$" + freereg + ", " + compiler.GetMethodSignature(method));

		/* Return value */
		Vector ret = new Vector();
		for (int32 i = 0; i < method.returnTypes.Size; i = i + 1)
			ret.Add(new RegisterValue(location, freereg + i,
				compiler.ResolveType([TypeCache] method.returnTypes[i])));
		return ret;
	}
}

class MultipleNode: Node
{
	public Vector nodes;

	public (Location location)
	{
		this.location = location;
		nodes = new Vector();
	}

	public override CompileStatement(Compiler compiler, int32 freereg, Context context) -> int32, int32
	{
		compiler.PushSymbolStack();
		int32 closed = 0, _freereg = freereg;
		for (int32 i = 0; i < nodes.Size; i = i + 1)
			closed, _freereg = ([Node] nodes[i]).CompileStatement(compiler, _freereg, context);
		compiler.PopSymbolStack();
		return closed, freereg;
	}
}

class DefinitionNode: Node
{
	public Node type;
	public Vector names;
	public Vector values;

	public (Location location)
	{
		this.location = location;
		names = new Vector();
		values = new Vector();
	}

	public override CompileStatement(Compiler compiler, int32 freereg, Context context) -> int32, int32
	{
		Type type = this.type.ToType(compiler);
		for (int32 i = 0; i < names.Size; i = i + 1)
		{
			Variable variable = new Variable();
			variable.regid = freereg;
			variable.type = type;

			/* TODO */
			([Hash] compiler.symbolTable.Peek()).Add([String] names[i], variable);

			Object vn = values[i];
			if (vn != null)
			{
				Node vnode = [Node] vn;
				LValue value = new VariableValue(location, freereg, type);
				vnode.CompileExpression(compiler, freereg, freereg, 0, false).ToLValue(compiler, value, freereg);
			}
			freereg = freereg + 1;
		}
		return 0, freereg;
	}
}

class IfNode: Node
{
	public Node condition;
	public Node trueBody, falseBody;

	public (Location location)
	{
		this.location = location;
	}

	public override CompileStatement(Compiler compiler, int32 freereg, Context context) -> int32, int32
	{
		if (falseBody == null)
		{
			/* If - Then */
			int32 falseTarget = compiler.GetNextLabelId();
			condition.CompileExpression(compiler, freereg, freereg, falseTarget, false)
				.ToJumpTarget(compiler, freereg, falseTarget, false);
			trueBody.CompileStatement(compiler, freereg, context);
			compiler.AddLabel(falseTarget);
			return 0, freereg;
		}
		else
		{
			/* If - Then - Else */
			int32 falseTarget = compiler.GetNextLabelId();
			int32 endTarget = compiler.GetNextLabelId();
			condition.CompileExpression(compiler, freereg, freereg, falseTarget, false)
				.ToJumpTarget(compiler, freereg, falseTarget, false);
			int32 thenClosed, elseClosed;
			thenClosed = trueBody.CompileStatement(compiler, freereg, context);
			if (thenClosed == 0)
				compiler.AddCode("jmp\t" + compiler.GetLabelName(endTarget));
			compiler.AddLabel(falseTarget);
			elseClosed = falseBody.CompileStatement(compiler, freereg, context);
			if (thenClosed == 0)
				compiler.AddLabel(endTarget);
			return thenClosed & elseClosed, freereg;
		}
	}
}

class ForNode: Node
{
	public Node init, condition, update;
	public Node body;

	public (Location location)
	{
		this.location = location;
	}

	public override CompileStatement(Compiler compiler, int32 freereg, Context context) -> int32, int32
	{
		compiler.PushSymbolStack();
		context.loopLevel = context.loopLevel + 1;
		int32 backupContinueLabelId = context.continueLabelId;
		int32 backupBreakLabelId = context.breakLabelId;
		context.contextType.Push(Int32.ToString(Context.Loop));

		int32 bodyTarget = compiler.GetNextLabelId();
		int32 conditionTarget;
		if (condition != null)
			conditionTarget = compiler.GetNextLabelId();
		int32 closed, _freereg = freereg;

		context.continueLabelId = 0;
		context.breakLabelId = 0;
		if (condition == null && update == null)
			context.continueLabelId = bodyTarget;

		if (init != null)
			closed, _freereg = init.CompileStatement(compiler, freereg, context);
		if (condition != null)
			compiler.AddCode("jmp\t" + compiler.GetLabelName(conditionTarget));
		compiler.AddLabel(bodyTarget);
		body.CompileStatement(compiler, _freereg, context);
		if ((condition != null || update != null) && context.continueLabelId > 0)
			compiler.AddLabel(context.continueLabelId);
		if (update != null)
			update.CompileList(compiler, _freereg, -1);
		if (condition == null)
			compiler.AddCode("jmp\t" + compiler.GetLabelName(bodyTarget));
		else
		{
			compiler.AddLabel(conditionTarget);
			condition.CompileExpression(compiler, _freereg, _freereg, bodyTarget, true)
				.ToJumpTarget(compiler, _freereg, bodyTarget, true);
		}

		if (context.breakLabelId > 0)
			compiler.AddLabel(context.breakLabelId);
		context.contextType.Pop();
		context.continueLabelId = backupContinueLabelId;
		context.breakLabelId = backupBreakLabelId;
		context.loopLevel = context.loopLevel - 1;
		compiler.PopSymbolStack();
		return 0, freereg;
	}
}

class WhileNode: Node
{
	public Node condition;
	public Node body;

	public (Location location)
	{
		this.location = location;
	}

	public override CompileStatement(Compiler compiler, int32 freereg, Context context) -> int32, int32
	{
		context.loopLevel = context.loopLevel + 1;
		int32 backupContinueLabelId = context.continueLabelId;
		int32 backupBreakLabelId = context.breakLabelId;
		context.contextType.Push(Int32.ToString(Context.Loop));

		int32 bodyTarget = compiler.GetNextLabelId();
		int32 conditionTarget = compiler.GetNextLabelId();

		context.continueLabelId = conditionTarget;
		context.breakLabelId = 0;
		compiler.AddCode("jmp\t" + compiler.GetLabelName(conditionTarget));
		compiler.AddLabel(bodyTarget);
		body.CompileStatement(compiler, freereg, context);
		compiler.AddLabel(conditionTarget);
		condition.CompileExpression(compiler, freereg, freereg, bodyTarget, true).ToJumpTarget(compiler, freereg, bodyTarget, true);

		if (context.breakLabelId > 0)
			compiler.AddLabel(context.breakLabelId);
		context.contextType.Pop();
		context.continueLabelId = backupContinueLabelId;
		context.breakLabelId = backupBreakLabelId;
		context.loopLevel = context.loopLevel - 1;
		return 0, freereg;
	}
}

class DoWhileNode: Node
{
	public Node condition;
	public Node body;

	public (Location location)
	{
		this.location = location;
	}

	public override CompileStatement(Compiler compiler, int32 freereg, Context context) -> int32, int32
	{
		context.loopLevel = context.loopLevel + 1;
		int32 backupContinueLabelId = context.continueLabelId;
		int32 backupBreakLabelId = context.breakLabelId;
		context.contextType.Push(Int32.ToString(Context.Loop));

		int32 bodyTarget = compiler.GetNextLabelId();

		context.continueLabelId = 0;
		context.breakLabelId = 0;
		compiler.AddLabel(bodyTarget);
		body.CompileStatement(compiler, freereg, context);
		if (context.continueLabelId > 0)
			compiler.AddLabel(context.continueLabelId);
		condition.CompileExpression(compiler, freereg, freereg, bodyTarget, true).ToJumpTarget(compiler, freereg, bodyTarget, true);

		if (context.breakLabelId > 0)
			compiler.AddLabel(context.breakLabelId);
		context.contextType.Pop();
		context.continueLabelId = backupContinueLabelId;
		context.breakLabelId = backupBreakLabelId;
		context.loopLevel = context.loopLevel - 1;
		return 0, freereg;
	}
}

class ReturnNode: Node
{
	public Vector values;

	public (Location location)
	{
		this.location = location;
		values = new Vector();
	}

	public override CompileStatement(Compiler compiler, int32 freereg, Context context) -> int32, int32
	{
		if (values.Size != compiler.CurrentMethod.returnTypes.Size && values.Size != 0)
			throw new CompilerException("Unmatched number of return values.", location);
		if (context.finallyLevel > 0)
			throw new CompilerException("Control cannot go out of the finally block.", location);
		if (context.tryCatchLevel > 0)
		{
			/* We are inside a try finally block */
			/* First, save supplied return values into return registers */
			for (int32 i = 0; i < values.Size; i = i + 1)
			{
				Node vnode = [Node] values[i];
				Type type = compiler.ResolveType([TypeCache] compiler.CurrentMethod.returnTypes[i]);
				vnode.CompileExpression(compiler, freereg, context.firstReturnRegister + i, 0, false)
					.ToTypedRegister(compiler, context.firstReturnRegister + 1, context.firstReturnRegister + 1, type);
			}
			/* Second, add leave instruction */
			compiler.AddCode("leave\t_Epilogue");
			/* Last, tell CompileMethod() that we need an epilogue */
			context.generateEpilogue = true;
		}
		else
		{
			/* Normal return */
			if (compiler.CurrentMethod.returnTypes.Size == 0)
				compiler.AddCode("ret");
			else if (compiler.CurrentMethod.returnTypes.Size == 1)
			{
				if (values.Size == 0)
					compiler.AddCode("ret\t$" + context.firstReturnRegister);
				else
				{
					RegisterValue value = ([Node] values[0]).CompileExpression(compiler, freereg, freereg, 0, false)
						.EnsureRegister(compiler, freereg);
					compiler.AddCode("ret\t$" + value.regid);
				}
			}
			else
			{
				if (values.Size == 0)
					compiler.AddCode("ret\t$" + context.firstReturnRegister + ", $"
						+ (context.firstReturnRegister + compiler.CurrentMethod.returnTypes.Size - 1));
				else
				{
					for (int32 i = 0; i < values.Size; i = i + 1)
					{
						Node vnode = [Node] values[i];
						Type type = compiler.ResolveType([TypeCache] compiler.CurrentMethod.returnTypes[i]);
						vnode.CompileExpression(compiler, freereg + i, freereg + i, 0, false)
							.ToTypedRegister(compiler, freereg + i, freereg + i, type);
					}
					compiler.AddCode("ret\t$" + freereg + ", $" + (freereg + values.Size - 1));
				}
			}
		}
		return 1, freereg;
	}
}

class ContinueNode: Node
{
	public (Location location)
	{
		this.location = location;
	}

	public override CompileStatement(Compiler compiler, int32 freereg, Context context) -> int32, int32
	{
		if (context.loopLevel == 0)
			throw new CompilerException("Not in a loop.", location);
		int32 ctx = Int32.Parse([String] context.contextType.Peek());
		if (ctx == Context.Finally)
			throw new CompilerException("Control cannot go out of the finally block.", location);

		context.continueLabelId = compiler.FixJumpTarget(context.continueLabelId);
		if (ctx == Context.TryCatch)
			compiler.AddCode("leave\t" + compiler.GetLabelName(context.continueLabelId));
		else
			compiler.AddCode("jmp\t" + compiler.GetLabelName(context.continueLabelId));
		return 1, freereg;
	}
}

class BreakNode: Node
{
	public (Location location)
	{
		this.location = location;
	}

	public override CompileStatement(Compiler compiler, int32 freereg, Context context) -> int32, int32
	{
		if (context.loopLevel == 0)
			throw new CompilerException("Not in a loop.", location);
		int32 ctx = Int32.Parse([String] context.contextType.Peek());
		if (ctx == Context.Finally)
			throw new CompilerException("Control cannot go out of the finally block.", location);

		context.breakLabelId = compiler.FixJumpTarget(context.breakLabelId);
		if (ctx == Context.TryCatch)
			compiler.AddCode("leave\t" + compiler.GetLabelName(context.breakLabelId));
		else
			compiler.AddCode("jmp\t" + compiler.GetLabelName(context.breakLabelId));
		return 1, freereg;
	}
}

class TryNode: Node
{
	public Node body;
	public Vector catchNodes;
	public Node finallyNode;

	public (Location location)
	{
		this.location = location;
		catchNodes = new Vector();
	}

	public override CompileStatement(Compiler compiler, int32 freereg, Context context) -> int32, int32
	{
		int32 endTarget = compiler.GetNextLabelId();

		if (finallyNode != null)
		{
			context.tryCatchLevel = context.tryCatchLevel + 1;
			context.contextType.Push(Int32.ToString(Context.TryCatch));
		}

		compiler.AddCode(".try {");
		compiler.Tab();
		int32 closed = body.CompileStatement(compiler, freereg, context);
		if (closed == 0)
			if (finallyNode == null)
				compiler.AddCode("jmp\t" + compiler.GetLabelName(endTarget));
			else
				compiler.AddCode("leave\t" + compiler.GetLabelName(endTarget));
		compiler.Untab();
		compiler.AddCode("}");
		for (int32 i = 0; i < catchNodes.Size; i = i + 1)
		{
			CatchNode cnode = [CatchNode] catchNodes[i];
			Type catchType = cnode.type.ToType(compiler);
			compiler.AddCode(".catch(" + catchType.ToString() + " $" + freereg + ") {");
			compiler.PushSymbolStack();
			Variable var = new Variable();
			var.regid = freereg;
			var.type = catchType;
			/* TODO */
			([Hash] compiler.symbolTable.Peek()).Add(cnode.name, var);
			compiler.Tab();
			int32 closed = cnode.body.CompileStatement(compiler, freereg + 1, context);
			if (closed == 0)
				if (finallyNode == null)
					compiler.AddCode("jmp\t" + compiler.GetLabelName(endTarget));
				else
					compiler.AddCode("leave\t" + compiler.GetLabelName(endTarget));
			compiler.Untab();
			compiler.AddCode("}");
			compiler.PopSymbolStack(); 
		}
		if (finallyNode != null)
		{
			context.tryCatchLevel = context.tryCatchLevel - 1;
			context.contextType.Pop();
			context.finallyLevel = context.finallyLevel + 1;
			context.contextType.Push(Int32.ToString(Context.Finally));

			compiler.AddCode(".finally {");
			compiler.Tab();
			finallyNode.CompileStatement(compiler, freereg, context);
			compiler.AddCode("endfinally");
			compiler.Untab();
			compiler.AddCode("}");

			context.contextType.Pop();
			context.finallyLevel = context.finallyLevel - 1;
		}
		compiler.AddLabel(endTarget);
		return 0, freereg;
	}
}

class CatchNode: Node
{
	public Node type;
	public String name;
	public Node body;

	public (Location location)
	{
		this.location = location;
	}
}

class ThrowNode: Node
{
	public Node exception;

	public (Location location)
	{
		this.location = location;
	}

	public override CompileStatement(Compiler compiler, int32 freereg, Context context) -> int32, int32
	{
		RegisterValue value = exception.CompileExpression(compiler, freereg, freereg, 0, false).EnsureRegister(compiler, freereg);
		compiler.AddCode("throw\t$" + value.regid);
		return 1, freereg;
	}
}

class Field
{
	public Class classObject;
	public int32 modifier;
	public String name;
	public TypeCache type;
	public Location location;

	public (Location location)
	{
		this.location = location;
	}
}

class Method
{
	public Class classObject;
	public int32 modifier;
	public String name;
	public String prototype;
	public Vector paramTypes;
	public Vector paramNames;
	public Vector returnTypes;
	public Vector returnNames;
	public int32 callingConvention;
	public String libraryName, originalName;
	public Node body;
	public Location location;

	public (Location location)
	{
		this.location = location;

		paramTypes = new Vector();
		paramNames = new Vector();
		returnTypes = new Vector();
		returnNames = new Vector();
	}
}

class Property
{
	public Class classObject;
	public int32 modifier;
	public String name;
	public TypeCache type;
	public Method getter;
	public Method setter;
	public Location location;

	public (Location location)
	{
		this.location = location;
	}
}

class Class
{
	public SourceFile sourceFile;
	public Namespace baseNamespace;
	public int32 modifier;
	public String name;
	public Node baseType;
	public Class baseClass;
	public Hash methods;
	public Hash fields;
	public Hash properties;
	public Location location;

	public (Location location)
	{
		this.location = location;

		methods = new Hash();
		fields = new Hash();
		properties = new Hash();
	}
}

class Namespace
{
	public String name;
	public Namespace base;
	Hash children;

	public (String name, Namespace base)
	{
		children = new Hash();
		this.base = base;
		if (base != null && base.name.Equals("") == 0)
			this.name = base.name + "." + name;
		else
			this.name = name;
	}
}

class SourceFile
{
	public String fileName;
	public Vector namespaces;

	public (String fileName, Namespace root)
	{
		this.fileName = fileName;
		this.namespaces = new Vector();
		this.namespaces.Add(root);
	}
}

class Modifier
{
	public static int32 Public, Private, Protected;
	public static int32 Static, Virtual, Override, Abstract;
	public static int32 Internal, Native, Interface, ValueType;
	public static Hash hash;

	public static Parse(String string) -> int32
	{
		/* HACK: int -> int32 */
		int32 found;
		Object value;
		if ((found, value = hash.Contains(string)) > 0)
			return Int32.Parse([String] value);
		else
			return 0;
	}

	public static ToString(int32 modifier) -> String
	{
		/* FIXME: Accessing private members */
		String ret = "";
		for (int32 i = 0; i < hash.Size; i = i + 1)
			if (modifier & Int32.Parse([String] hash.values[i]) > 0)
				if (ret.Equals("") > 0)
					ret = ret + [String] hash.keys[i];
				else
					ret = ret + " " + [String] hash.keys[i];
		return ret;
	}

	static ()
	{
		Modifier.Public, Modifier.Private, Modifier.Protected = 1, 2, 4;
		Modifier.Static, Modifier.Virtual, Modifier.Override, Modifier.Abstract = 8, 16, 32, 64;
		Modifier.Internal, Modifier.Native, Modifier.Interface, Modifier.ValueType = 128, 256, 512, 1024;

		hash = new Hash();
		hash.Add("public", Int32.ToString(Modifier.Public));
		hash.Add("private", Int32.ToString(Modifier.Private));
		hash.Add("protected", Int32.ToString(Modifier.Protected));
		hash.Add("static", Int32.ToString(Modifier.Static));
		hash.Add("virtual", Int32.ToString(Modifier.Virtual));
		hash.Add("override", Int32.ToString(Modifier.Override));
		hash.Add("abstract", Int32.ToString(Modifier.Abstract));
		hash.Add("internal", Int32.ToString(Modifier.Internal));
		hash.Add("native", Int32.ToString(Modifier.Native));
		hash.Add("interface", Int32.ToString(Modifier.Interface));
		hash.Add("valuetype", Int32.ToString(Modifier.ValueType));
	}
}

class CallingConvention
{
	public static int32 Unknown, Stdcall;

	public static ToString(int32 cc) -> String
	{
		if (cc == CallingConvention.Unknown)
			return "unknown";
		else if (cc == CallingConvention.Stdcall)
			return "stdcall";
		return "";
	}

	public static Parse(String cc) -> int32
	{
		if (cc.Equals("unknown") > 0)
			return CallingConvention.Unknown;
		else if (cc.Equals("stdcall") > 0)
			return CallingConvention.Stdcall;
		else
			return 0;
	}

	static ()
	{
		CallingConvention.Unknown, CallingConvention.Stdcall = 1, 2;
	}
}
